<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#0f766e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="Fin Snapshot">
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icon-192.png">
  <title>Rubin Financial Snapshot</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700&family=Anton+SC&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      --bg: #f7f8fa;
      --bg-card: #ffffff;
      --text: #1a1d21;
      --text-muted: #6b7280;
      --text-light: #9ca3af;
      --border: #e5e7eb;
      --accent: #0f766e;
      --accent-light: #14b8a6;
      --header-bg: #0f172a;
      --header-text: #f8fafc;
      --header-bg-muted: #1e293b;
      --shadow-sm: 0 1px 2px rgba(0,0,0,0.04);
      --shadow: 0 4px 6px -1px rgba(0,0,0,0.05), 0 2px 4px -2px rgba(0,0,0,0.05);
      --shadow-lg: 0 10px 15px -3px rgba(0,0,0,0.05), 0 4px 6px -4px rgba(0,0,0,0.05);
      --radius: 12px;
      --radius-sm: 8px;
    }
    * { box-sizing: border-box; }
    body {
      font-family: 'DM Sans', system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 1.75rem 0.5rem 2.5rem;
      background: var(--bg);
      color: var(--text);
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
    }
    .page-container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 0.5rem;
    }
    .chart-section {
      margin-bottom: 1.5rem;
    }
    .chart-section:last-of-type {
      margin-bottom: 0;
    }
    .chart-section[data-visible="false"] {
      display: none;
    }
    .chart-wrapper {
      width: 100%;
      height: 800px;
      background: rgb(64,64,64);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      border: 1px solid var(--border);
      padding: 0;
      overflow: hidden;
    }
    .chart-body {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
      margin: 0.5rem 0.75rem 0.75rem 0.75rem;
      padding: 0.75rem;
      background: #f8f9fa;
      border: 1px solid var(--border);
      border-radius: 10px;
    }
    .chart-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding: 0.75rem 0.85rem;
      background: var(--header-bg);
      color: var(--header-text);
      border-radius: var(--radius) var(--radius) 0 0;
    }
    .chart-header h2 {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 700;
      letter-spacing: 0.02em;
      color: var(--header-text);
    }
    .chart-header-controls {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin-left: auto;
    }
    .chart-header .chart-select {
      background: rgba(255,255,255,0.1);
      color: var(--header-text);
      border: 1px solid rgba(255,255,255,0.2);
    }
    .chart-header .chart-select:hover {
      background: rgba(255,255,255,0.15);
    }
    .chart-header .info-icon {
      border-color: rgba(255,255,255,0.5);
      color: rgba(255,255,255,0.8);
    }
    .chart-select {
      background: var(--bg-card);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 0.5rem 1rem;
      font-size: 0.8125rem;
      font-family: inherit;
      cursor: pointer;
      transition: border-color 0.15s, background 0.15s;
    }
    .chart-select:hover {
      border-color: var(--text-light);
    }
    .chart-select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(15, 118, 110, 0.2);
    }
    .chart-body .chart-container {
      padding: 0.5rem 0;
    }
    .chart-container {
      flex: 1;
      position: relative;
      min-height: 0;
      padding: 0.85rem 0.85rem;
      overflow: hidden;
    }
    .chart-container canvas {
      width: 100% !important;
      height: 100% !important;
    }
    .projection-inputs {
      padding: 0.5rem 0.85rem;
      border-bottom: 1px solid var(--border);
      font-size: 0.8125rem;
      background: #fafbfc;
    }
    .projection-inputs-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.4rem 1rem;
      margin-bottom: 0.35rem;
    }
    .projection-inputs-row:last-child {
      margin-bottom: 0;
    }
    .projection-inputs-row.row1,
    .projection-inputs-row.row2 {
      justify-content: center;
    }
    .projection-inputs-row .spacer {
      width: 1rem;
    }
    .projection-inputs label {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      color: var(--text-muted);
    }
    .projection-inputs input {
      width: 6rem;
      padding: 0.3rem 0.5rem;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 0.8125rem;
      font-family: inherit;
      text-align: right;
      background: var(--bg-card);
      transition: border-color 0.15s;
    }
    .projection-inputs input:focus {
      outline: none;
      border-color: var(--accent);
    }
    .projection-inputs input.input-narrow {
      width: 3.75rem;
    }
    .projection-inputs input.input-simulations {
      width: 4.5rem;
    }
    .projection-inputs input.input-mc,
    .chart-header input.input-mc {
      width: 3rem;
      text-align: right;
    }
    .projection-inputs .net-return {
      color: var(--text);
      font-weight: 600;
    }
    .balance-exclusions input[type="checkbox"] {
      width: auto;
      padding: 0;
      margin-right: 0.35rem;
      cursor: pointer;
    }
    .balance-exclusions .projection-inputs-row {
      gap: 0.4rem 2rem;
    }
    .projection-inputs-row span[style*="font-weight: bold"] {
      font-weight: 600;
      color: var(--text);
    }
    details {
      margin: 0.75rem 0.85rem 1rem;
      font-size: 0.8125rem;
      color: var(--text-muted);
    }
    details summary {
      cursor: pointer;
      padding: 0.35rem 0;
      font-weight: 500;
      color: var(--text);
    }
    details summary:hover {
      color: var(--accent);
    }
    details[open] summary {
      margin-bottom: 0.5rem;
    }
    .note code {
      background: rgba(0,0,0,0.06);
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
      font-size: 0.7rem;
    }
    .info-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      position: relative;
      margin-left: 0.25rem;
      width: 1em;
      height: 1em;
      border-radius: 50%;
      border: 1px solid currentColor;
      font-size: 0.6em;
      font-style: normal;
      font-weight: 500;
      cursor: help;
      vertical-align: middle;
      opacity: 0.7;
    }
    .info-icon:hover {
      opacity: 1;
    }
    .info-icon .info-tooltip {
      visibility: hidden;
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(100% + 10px);
      width: 320px;
      padding: 1rem 1.25rem;
      background: var(--header-bg);
      color: var(--header-text);
      font-size: 0.75rem;
      font-weight: 400;
      line-height: 1.6;
      text-align: left;
      white-space: normal;
      border-radius: var(--radius-sm);
      box-shadow: var(--shadow-lg);
      z-index: 100;
    }
    .info-icon:hover .info-tooltip {
      visibility: visible;
    }
    .key-figures-wrapper {
      width: 100%;
      padding: 1.25rem 1.5rem;
      background: var(--bg-card);
      display: flex;
      align-items: center;
      justify-content: space-around;
      flex-wrap: wrap;
      gap: 1rem 0;
    }
    .key-figures-chart-wrapper {
      height: auto;
      min-height: 0;
      background: var(--bg-card);
      border: 1px solid black;
      box-shadow: none;
      border-radius: var(--radius);
    }
    .key-figures-chart-wrapper .key-figures-wrapper {
      margin-top: 0.5rem;
    }
    .key-figures-wrapper .key-fig-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.25rem;
      min-width: 140px;
    }
    .key-figures-wrapper .key-fig-label {
      font-size: 0.75rem;
      font-weight: 500;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .key-figures-wrapper .key-fig-value {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--text);
    }
    .page-header {
      margin-bottom: 1.5rem;
      display: flex;
      align-items: flex-end;
      gap: 1.3rem;
    }
    .page-header-logo {
      height: 176px;
      width: auto;
      display: block;
      flex-shrink: 0;
    }
    .page-header-right {
      flex: 1;
      min-width: 0;
      display: flex;
      flex-direction: column;
    }
    .page-header-brand {
      padding: 0.15rem 0 0.05rem 1rem;
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-height: 128px;
    }
    .page-header-brand-inner {
      border-top: 4px solid rgb(0, 0, 0);
      border-bottom: 3px solid rgb(0, 0, 0);
      padding: 0.15rem 1rem 0.15rem 0;
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
    }
    .page-header-year {
      margin: 0;
      font-family: 'Anton SC', sans-serif;
      font-size: 5rem;
      font-weight: 500;
      color: var(--text);
      flex-shrink: 0;
      letter-spacing: 0.01em;
    }
    .page-header-title {
      margin: 0;
      font-family: 'Anton SC', sans-serif;
      font-size: 5rem;
      font-weight: 500;
      color: var(--text);
      letter-spacing: 0.01em;
    }
    .page-subtitle {
      margin: 0;
      font-size: 0.9375rem;
      color: var(--text-muted);
      font-weight: 400;
    }
    .chart-header button.chart-select,
    .chart-header select.chart-select {
      padding: 0.4rem 0.85rem;
      font-size: 0.8125rem;
    }
    .note {
      margin-top: 2rem;
      padding: 1rem 1.25rem;
      background: var(--bg-card);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      font-size: 0.8125rem;
      color: var(--text-muted);
      text-align: center;
    }
    details summary {
      user-select: none;
    }
    .breakdown-table {
      border-collapse: collapse;
      width: 100%;
      font-size: 0.8125rem;
    }
    .breakdown-table th,
    .breakdown-table td {
      padding: 0.35rem 0.6rem;
      border-bottom: 1px solid var(--border);
      text-align: left;
    }
    .breakdown-table th {
      font-weight: 600;
      color: var(--text-muted);
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    .breakdown-table td { color: var(--text); }
    .breakdown-table tr.committed-row td { color: #888; }
    .breakdown-table tr td:nth-child(n+2),
    .breakdown-table tr th:nth-child(n+2) { text-align: right; }
    .page-header-nav-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-top: 0.02rem;
      padding-left: 1rem;
    }
    .page-header-csv-update {
      font-size: 0.8125rem;
      color: rgba(0, 0, 0, 0.5);
    }
    .page-nav {
      display: flex;
      gap: 1.25rem;
      justify-content: flex-end;
    }
    .page-tab {
      font-size: 1.375rem;
      font-weight: 700;
      font-family: inherit;
      color: var(--text-muted);
      text-decoration: none;
      cursor: pointer;
      transition: color 0.15s;
    }
    .page-tab:hover {
      color: var(--text);
    }
    .page-tab[data-active="true"] {
      color: var(--text);
    }
    .page-content {
      display: none;
    }
    .page-content[data-visible="true"] {
      display: block;
    }
    .budget-page-wrapper {
      max-width: 1400px;
      width: 100%;
      margin: 0 auto;
    }
    .budget-grouping {
      margin-bottom: 1.5rem;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 0;
      overflow: hidden;
    }
    .budget-grouping-title {
      font-weight: 600;
      font-size: 1rem;
      color: var(--header-text);
      margin: 0;
      padding: 0.5rem 0.75rem;
      border-bottom: 1px solid rgba(255,255,255,0.15);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      cursor: pointer;
      user-select: none;
      background: var(--header-bg);
    }
    .budget-grouping-title-inner { display: flex; align-items: center; gap: 0.5rem; }
    .budget-group-total {
      font-weight: 500;
      font-size: 0.9rem;
      opacity: 0.9;
    }
    .budget-grouping-title:hover {
      background: #1e293b;
    }
    .budget-grouping[data-expanded="false"] .budget-grouping-title {
      border-bottom: none;
    }
    .budget-grouping-toggle {
      display: inline-block;
      font-size: 2.0rem;
      transition: transform 0.2s;
      color: var(--header-text);
    }
    .budget-grouping[data-expanded="true"] .budget-grouping-toggle { transform: rotate(0deg); }
    .budget-grouping[data-expanded="false"] .budget-grouping-toggle { transform: rotate(-90deg); }
    .budget-grouping-categories {
      padding: 0.5rem;
      background: rgb(100, 50, 50);
    }
    .budget-grouping[data-grouping="Income"] .budget-grouping-categories {
      background: rgb(50, 100, 50);
    }
    .budget-grouping[data-expanded="false"] .budget-grouping-categories {
      display: none;
    }
    .budget-category-card {
      background: var(--bg-card);
      border-radius: 8px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      padding: 0.5rem 0.75rem;
      margin-bottom: 0.5rem;
    }
    .budget-category-card:last-child {
      margin-bottom: 0;
    }
    .budget-category-name {
      font-weight: 500;
      font-size: 0.875rem;
      color: var(--text);
      margin-bottom: 0.5rem;
    }
    .budget-category-chart {
      height: 52px;
      margin-bottom: 0.35rem;
      position: relative;
    }
    .budget-category-chart canvas {
      width: 100% !important;
      height: 100% !important;
    }
    .budget-ignored-note {
      color: #888;
      font-size: 0.8rem;
      margin-top: 0.35rem;
    }
    .budget-category-card details {
      margin: 0;
    }
    .budget-category-card details summary {
      padding: 0.15rem 0;
    }
    .budget-category-card details[open] summary {
      margin-bottom: 0.2rem;
    }
    .budget-category-card .breakdown-content {
      padding: 0;
      margin: 0;
    }
    .budget-totals-summary {
      padding: 1.25rem 1.5rem;
      margin-bottom: 1.5rem;
      background: var(--header-bg);
      color: var(--header-text);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      border: 2px solid var(--header-bg);
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 0.5rem;
    }
    .budget-committed-error {
      color: #ef4444;
      font-weight: 600;
      font-size: 1rem;
    }
    .budget-totals-chart-wrap {
      width: 100%;
      height: 88px;
      min-height: 88px;
      position: relative;
    }
    .budget-totals-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 2rem;
      flex-wrap: wrap;
    }
    .budget-totals-stats {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      gap: 1.5rem;
      flex-wrap: wrap;
      width: 100%;
    }
    .budget-totals-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem 1rem;
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: var(--radius-sm);
      flex: 1;
      min-width: 0;
    }
    .budget-totals-group.budget-totals-group-narrow {
      flex: 0 0 auto;
      min-width: 280px;
    }
    .budget-totals-group-header {
      font-size: 1.25rem;
      font-weight: 700;
      color: rgba(255,255,255,0.95);
      margin-bottom: 0.15rem;
    }
    .budget-totals-group-items {
      display: flex;
      flex-direction: row;
      gap: 1.25rem;
      justify-content: center;
    }
    .budget-totals-group-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.25rem;
    }
    .budget-totals-group-item .budget-totals-label {
      font-size: 0.75rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      opacity: 0.9;
      text-align: center;
    }
    .budget-totals-group-item .budget-totals-value {
      font-size: 1.35rem;
      font-weight: 700;
    }
    .budget-totals-line2 {
      flex-basis: 100%;
      display: flex;
      gap: 3rem;
      align-items: center;
      margin-top: 0.35rem;
      padding-left: 4px;
    }
    .budget-totals-summary .budget-total-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.25rem;
    }
    .budget-totals-summary .budget-total-label {
      font-size: 0.75rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      opacity: 0.9;
    }
    .budget-totals-summary .budget-total-value {
      font-size: 1.75rem;
      font-weight: 700;
      letter-spacing: -0.02em;
    }
    .budget-save-csv-btn {
      margin-left: auto;
      align-self: center;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      font-weight: 500;
      font-family: inherit;
      cursor: pointer;
      background: rgba(255,255,255,0.2);
      color: inherit;
      border: 1px solid currentColor;
      border-radius: var(--radius-sm);
    }
    .budget-save-csv-btn:hover {
      background: rgba(255,255,255,0.3);
    }
    .budget-category-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.35rem;
      cursor: pointer;
      user-select: none;
    }
    .budget-category-card[data-expanded="false"] .budget-category-header {
      margin-bottom: 0;
    }
    .budget-category-header-inner {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex: 1;
      min-width: 0;
    }
    .budget-category-toggle {
      display: inline-block;
      font-size: 2.0rem;
      transition: transform 0.2s;
      color: #000;
      flex-shrink: 0;
    }
    .budget-category-card[data-expanded="true"] .budget-category-toggle { transform: rotate(0deg); }
    .budget-category-card[data-expanded="false"] .budget-category-toggle { transform: rotate(-90deg); }
    .budget-category-body {
      margin-top: 0.35rem;
    }
    .budget-category-card[data-expanded="false"] .budget-category-body {
      display: none;
    }
    .budget-category-header .budget-category-label {
      font-weight: 500;
      font-size: 0.875rem;
      color: var(--text);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .budget-category-header .budget-input {
      width: 7rem;
      padding: 0.25rem 0.5rem;
      font-size: 0.875rem;
      font-family: inherit;
      text-align: right;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--bg);
    }
    @media (max-width: 768px) {
      body { padding: 1.25rem 0.5rem 2rem; }
      .chart-header { padding: 0.65rem 0.75rem; }
      .chart-container { padding: 0.65rem 0.75rem; }
      .projection-inputs { padding: 0.4rem 0.75rem; }
      .key-figures-wrapper { padding: 1rem 1rem; gap: 0.75rem; }
    }
    .error-page { min-height: 100vh; background: #ffffff; display: flex; flex-direction: column; align-items: center; padding: 2rem 1rem; }
    .error-page h1 { margin: 0 0 0.25rem; font-size: 1.75rem; color: var(--text); }
    .error-page .error-box { max-width: 480px; width: 100%; margin: 2rem 0; padding: 1.75rem; background: var(--bg-card); border: 2px solid var(--border); border-radius: var(--radius); box-shadow: var(--shadow-lg); }
    .error-page .error-box h2 { margin: 0 0 0.75rem; font-size: 1.1rem; color: var(--text); }
    .error-page .error-box p { margin: 0 0 1rem; color: var(--text-muted); font-size: 0.9375rem; line-height: 1.6; }
    .error-page .error-box p:last-of-type { margin-bottom: 0; }
    .error-page .error-command-row { display: flex; align-items: center; gap: 0.5rem; margin: 0.5rem 0; padding: 0.6rem 0.85rem; background: var(--bg); border-radius: var(--radius-sm); font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace; font-size: 0.875rem; }
    .error-page .error-command-row code { flex: 1; overflow-x: auto; white-space: nowrap; }
    .error-page .copy-btn { flex-shrink: 0; display: flex; align-items: center; justify-content: center; width: 32px; height: 32px; padding: 0; border: 1px solid var(--border); border-radius: var(--radius-sm); background: var(--bg-card); color: var(--text-muted); cursor: pointer; transition: color 0.15s, border-color 0.15s, background 0.15s; }
    .error-page .copy-btn:hover { color: var(--accent); border-color: var(--accent); background: rgba(15, 118, 110, 0.08); }
    .error-page .copy-btn.copied { color: #16a34a; border-color: #16a34a; }
    .error-page .copy-btn svg { width: 16px; height: 16px; }
  </style>
</head>
<body>
  <div class="page-container">
  <header class="page-header">
    <img src="Financial_Snapshot_Logo.png" alt="" class="page-header-logo">
    <div class="page-header-right">
      <div class="page-header-brand">
        <div class="page-header-brand-inner">
          <h1 class="page-header-title">Rubin Financial Snapshot</h1>
          <span class="page-header-year" id="header-year"></span>
        </div>
      </div>
      <div class="page-header-nav-row">
        <span class="page-header-csv-update" id="header-csv-update">Last complete .csv update —</span>
        <nav class="page-nav">
          <a href="#" class="page-tab" data-active="true" data-page="investments">Investments</a>
          <a href="#" class="page-tab" data-active="false" data-page="budget">Budget</a>
        </nav>
      </div>
    </div>
  </header>
  <div id="page-investments" class="page-content" data-visible="true">
  <div id="chart-sections">
    <section id="chart-key-figures" class="chart-section" data-chart-id="key-figures" data-visible="true">
      <div class="chart-wrapper key-figures-chart-wrapper">
        <div class="chart-header">
          <h2>Key Figures</h2>
        </div>
      <div class="key-figures-wrapper">
        <div class="key-fig-item"><span class="key-fig-label">CPI</span><span class="key-fig-value" id="keyfig-cpi">—</span></div>
        <div class="key-fig-item"><span class="key-fig-label">Fed Funds Rate</span><span class="key-fig-value" id="keyfig-fedfunds">—</span></div>
        <div class="key-fig-item"><span class="key-fig-label">TFDXX</span><span class="key-fig-value" id="keyfig-tfdxx">—</span></div>
        <div class="key-fig-item"><span class="key-fig-label">LA Home Index</span><span class="key-fig-value" id="keyfig-laHome">—</span></div>
      </div>
      </div>
    </section>
    <section id="chart-balance" class="chart-section" data-chart-id="balance" data-visible="true">
      <div class="chart-wrapper chart-full-width">
        <div class="chart-header">
          <h2>Net Investment</h2>
          <div class="chart-header-controls">
            <select id="balance-viewSelect" class="chart-select">
              <option value="1month" selected>1 month</option>
              <option value="90days">90 days</option>
              <option value="year">This year</option>
              <option value="lifetime">Lifetime</option>
            </select>
          </div>
        </div>
        <div class="chart-body">
        <div class="projection-inputs balance-exclusions">
          <div class="projection-inputs-row row1">
            <label><input type="checkbox" id="balance-exclude-realestate" checked> Exclude Real Estate</label>
            <label><input type="checkbox" id="balance-exclude-automobiles" checked> Exclude Automobiles</label>
            <label><input type="checkbox" id="balance-exclude-nonmerrill"> Exclude non-Merrill</label>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="balance-canvas"></canvas>
        </div>
        <details>
          <summary>Data</summary>
          <div id="balance-data-breakdown" class="breakdown-content" style="max-height: 200px; overflow: auto;"></div>
        </details>
        </div>
      </div>
    </section>
    <section id="chart-wealth-projection" class="chart-section" data-chart-id="wealth-projection" data-visible="true">
      <div class="chart-wrapper chart-full-width">
        <div class="chart-header">
          <h2>Basic Wealth projection</h2>
          <div class="chart-header-controls">
            <button type="button" class="inputs-save-csv-btn chart-select">Save .csv</button>
            <button type="button" id="wealth-reset" class="chart-select">Reset</button>
          </div>
        </div>
        <div class="chart-body">
        <div class="projection-inputs">
          <div class="projection-inputs-row row1">
            <label>Pre Tax Return <input type="text" class="input-narrow" id="wealth-preTaxReturn" value="7.30">%</label>
            <label>State/Fed Tax Rate <input type="text" class="input-narrow" id="wealth-taxRate" value="30.00">%</label>
            <label class="net-return">Net Return <span id="wealth-netReturn">4.02</span>%</label>
            <label>Cost of Living $<input type="text" id="wealth-costOfLiving" value="1500000"></label>
            <label>Inflation <input type="text" class="input-narrow" id="wealth-inflation" value="3.0">%</label>
            <label>Home Appreciation <input type="text" class="input-narrow" id="wealth-homeAppreciation" value="3">%</label>
          </div>
          <div class="projection-inputs-row row2">
            <span style="font-weight: bold;">Downsize House</span>
            <label>Year <input type="text" class="input-narrow" id="wealth-downsizeHouseYear" value="2037"></label>
            <label>Amount $<input type="text" id="wealth-downsizeHouseAmount" value="10000000"></label>
            <span class="spacer"></span>
            <span style="font-weight: bold;">Downsize COL</span>
            <label>Year <input type="text" class="input-narrow" id="wealth-downsizeCOLYear" value="2037"></label>
            <label>Amount $<input type="text" id="wealth-downsizeCOLAmount" value="-200000"></label>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="wealthProjection-canvas"></canvas>
        </div>
        <details>
          <summary>Year-by-year breakdown</summary>
          <div id="wealth-breakdown" class="breakdown-content" style="max-height: 200px; overflow: auto;"></div>
        </details>
        </div>
      </div>
    </section>
    <section id="chart-wealth-montecarlo" class="chart-section" data-chart-id="wealth-montecarlo" data-visible="true">
      <div class="chart-wrapper chart-full-width">
        <div class="chart-header">
          <h2>Monte Carlo<span class="info-icon">i<span class="info-tooltip">This simulation runs thousands of parallel scenarios (default 10,000) to project your wealth over time. Each scenario uses different random draws for each year.

Investment returns: Drawn from a normal distribution around your assumed net return, with volatility you specify (default 17%). Returns and inflation are correlated (default -0.3) to model stagflation.

Real estate: Home value grows each year by a random appreciation rate centered on your assumed rate, with volatility you specify (default 5%).

Inflation: Each year's inflation is random (normal around your assumed rate, with default 1.5% volatility and a 1% floor). Cost of living rises with this simulated inflation in each scenario.

For each scenario, net investments, real estate, and net worth are projected year by year. The chart shows the 10th, 25th, 50th, 75th, and 90th percentiles at each year, plus 5 sample paths. Downsize house and COL changes are applied in the year you specify.</span></span></h2>
          <div class="chart-header-controls">
            <button type="button" class="inputs-save-csv-btn chart-select">Save .csv</button>
            <button type="button" id="mc-rerun" class="chart-select">Rerun</button>
            <button type="button" id="mc-reset" class="chart-select">Reset</button>
          </div>
        </div>
        <div class="chart-body">
        <div class="projection-inputs">
          <div class="projection-inputs-row row1">
            <label>Simulations <input type="text" class="input-narrow input-simulations" id="mc-simulations" value="10000"></label>
            <label>Return volatility <input type="text" class="input-mc" id="mc-returnVolatility" value="17">%</label>
            <label>Home appreciation vol. <input type="text" class="input-mc" id="mc-homeApprecVolatility" value="5">%</label>
            <label>Inflation vol. <input type="text" class="input-mc" id="mc-inflationVolatility" value="1.5">%</label>
            <label>Budget vol. <input type="text" class="input-mc" id="mc-budgetVolatility" value="20">%</label>
            <label>Infl.–return corr. <input type="text" class="input-mc" id="mc-inflationReturnCorr" value="-0.3"></label>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="wealthMonteCarlo-canvas"></canvas>
        </div>
        <details>
          <summary>Year-by-year breakdown (50% Net Investment path)</summary>
          <div id="mc-breakdown" class="breakdown-content" style="max-height: 200px; overflow: auto;"></div>
        </details>
        </div>
      </div>
    </section>
  </div>
  </div>
  <div id="page-budget" class="page-content" data-visible="false">
    <div class="budget-page-wrapper">
      <div id="budget-totals-summary" class="budget-totals-summary"></div>
      <div id="budget-content"></div>
    </div>
  </div>
  </div>

  <script>
    if ('scrollRestoration' in history) history.scrollRestoration = 'manual';
    window.addEventListener('load', () => window.scrollTo(0, 0));
    (function() {
      const el = document.getElementById('header-year');
      if (el) el.textContent = "'" + new Date().getFullYear().toString().slice(-2);
    })();
    function debounce(fn, ms) {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(null, args), ms);
      };
    }
    async function findBalancesCsvPath() {
      const basePath = window.location.pathname.replace(/\/[^/]*$/, '') || '/';
      const dirUrl = basePath + (basePath.endsWith('/') ? '' : '/');
      try {
        const r = await fetch(dirUrl);
        const html = await r.text();
        const linkRe = /<a\s+href="([^"]+)"/gi;
        const candidates = [];
        let m;
        while ((m = linkRe.exec(html)) !== null) {
          const href = decodeURIComponent(m[1]).replace(/^\.\//, '');
          if (href.startsWith('Balances') && /\.csv$/i.test(href)) candidates.push(href);
        }
        candidates.sort();
        return candidates.length > 0 ? candidates[candidates.length - 1] : 'Balances.csv';
      } catch (_) { return 'Balances.csv'; }
    }
    async function findTransactionsCsvPath() {
      const basePath = window.location.pathname.replace(/\/[^/]*$/, '') || '/';
      const dirUrl = basePath + (basePath.endsWith('/') ? '' : '/');
      try {
        const r = await fetch(dirUrl);
        const html = await r.text();
        const linkRe = /<a\s+href="([^"]+)"/gi;
        const candidates = [];
        let m;
        while ((m = linkRe.exec(html)) !== null) {
          const href = decodeURIComponent(m[1]).replace(/^\.\//, '');
          if (href.toLowerCase().includes('transactions') && /\.csv$/i.test(href)) candidates.push(href);
        }
        candidates.sort();
        return candidates.length > 0 ? candidates[candidates.length - 1] : 'Transactions.csv';
      } catch (_) { return 'Transactions.csv'; }
    }
    async function getEarliestCsvUpdateDate() {
      try {
        const [balPath, txPath] = await Promise.all([findBalancesCsvPath(), findTransactionsCsvPath()]);
        const [balResp, txResp] = await Promise.all([
          fetch(balPath, { method: 'HEAD' }),
          fetch(txPath, { method: 'HEAD' })
        ]);
        const parseLastModified = (resp) => {
          const lm = resp.headers.get('Last-Modified');
          return lm ? new Date(lm) : null;
        };
        const balDate = parseLastModified(balResp);
        const txDate = parseLastModified(txResp);
        const dates = [balDate, txDate].filter(d => d && !isNaN(d.getTime()));
        if (dates.length === 0) return null;
        return new Date(Math.min(...dates.map(d => d.getTime())));
      } catch (_) {
        return null;
      }
    }
    function formatLongDate(d) {
      const months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
      return months[d.getMonth()] + ' ' + d.getDate() + ', ' + d.getFullYear();
    }
    function matchesBudgetLimits(baseName) {
      const normalized = baseName.toLowerCase().replace(/_/g, '-');
      return normalized.startsWith('budget-limits') && /\.csv$/i.test(baseName);
    }
    async function findBudgetLimitsCsvPath() {
      const basePath = window.location.pathname.replace(/\/[^/]*$/, '') || '/';
      const dirUrl = basePath + (basePath.endsWith('/') ? '' : '/');
      try {
        const r = await fetch(dirUrl);
        const html = await r.text();
        const linkRe = /<a\s+href="([^"]+)"/gi;
        const candidates = [];
        let m;
        while ((m = linkRe.exec(html)) !== null) {
          const href = decodeURIComponent(m[1]).replace(/^\.\//, '');
          const baseName = href.split('/').pop() || '';
          if ((baseName.toLowerCase().startsWith('budget_limits') || matchesBudgetLimits(baseName)) && /\.csv$/i.test(baseName)) candidates.push(href);
        }
        candidates.sort();
        if (candidates.length > 0) return candidates[candidates.length - 1];
      } catch (_) {}
      try {
        const path = basePath ? basePath + (basePath.endsWith('/') ? '' : '/') + 'budget_limits.csv' : 'budget_limits.csv';
        const resp = await fetch(path, { method: 'HEAD' });
        if (resp.ok) return path;
      } catch (_) {}
      return null;
    }
    async function findBudgetCommittedCsvPath() {
      const basePath = window.location.pathname.replace(/\/[^/]*$/, '') || '/';
      const dirUrl = basePath + (basePath.endsWith('/') ? '' : '/');
      try {
        const r = await fetch(dirUrl);
        const html = await r.text();
        const linkRe = /<a\s+href="([^"]+)"/gi;
        const candidates = [];
        let m;
        while ((m = linkRe.exec(html)) !== null) {
          const href = decodeURIComponent(m[1]).replace(/^\.\//, '');
          const baseName = href.split('/').pop() || '';
          if (baseName.toLowerCase().includes('budget_committed') && /\.csv$/i.test(baseName)) candidates.push(href);
        }
        candidates.sort();
        if (candidates.length > 0) return candidates[candidates.length - 1];
      } catch (_) {}
      const fallbacks = ['budget_committed.csv', 'budget_committed - Sheet1.csv'];
      for (const name of fallbacks) {
        try {
          const path = basePath ? basePath + (basePath.endsWith('/') ? '' : '/') + name : name;
          const resp = await fetch(path, { method: 'HEAD' });
          if (resp.ok) return path;
        } catch (_) {}
      }
      return null;
    }
    function matchesFinancialSnapshotInputs(baseName) {
      const normalized = baseName.toLowerCase().replace(/_/g, '-');
      return normalized.startsWith('financial-snapshot-inputs') && /\.csv$/i.test(baseName);
    }
    async function findFinancialSnapshotInputsCsvPath() {
      const basePath = window.location.pathname.replace(/\/[^/]*$/, '') || '/';
      const dirUrl = basePath + (basePath.endsWith('/') ? '' : '/');
      try {
        const r = await fetch(dirUrl);
        const html = await r.text();
        const linkRe = /<a\s+href="([^"]+)"/gi;
        const candidates = [];
        let m;
        while ((m = linkRe.exec(html)) !== null) {
          const href = decodeURIComponent(m[1]).replace(/^\.\//, '');
          const baseName = href.split('/').pop() || '';
          if (matchesFinancialSnapshotInputs(baseName)) candidates.push(href);
        }
        candidates.sort();
        if (candidates.length > 0) return candidates[candidates.length - 1];
      } catch (_) {}
      const fallbacks = ['financial-snapshot-inputs.csv', 'financial_snapshot_inputs.csv'];
      for (const name of fallbacks) {
        try {
          const path = basePath ? basePath + (basePath.endsWith('/') ? '' : '/') + name : name;
          const resp = await fetch(path, { method: 'HEAD' });
          if (resp.ok) return path;
        } catch (_) {}
      }
      return null;
    }
    function parseCsvRow(line) {
      const result = [];
      let current = '';
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const c = line[i];
        if (c === '"') { inQuotes = !inQuotes; continue; }
        if (!inQuotes && c === ',') { result.push(current.trim()); current = ''; continue; }
        current += c;
      }
      result.push(current.trim());
      return result;
    }
    function parseCsvLines(text) {
      const rows = [];
      let row = '';
      let inQuotes = false;
      for (let i = 0; i < text.length; i++) {
        const c = text[i];
        if (c === '"') { inQuotes = !inQuotes; row += c; continue; }
        if (!inQuotes && (c === '\n' || c === '\r')) {
          if (row.trim()) rows.push(parseCsvRow(row));
          row = '';
          if (c === '\r' && text[i + 1] === '\n') i++;
          continue;
        }
        row += c;
      }
      if (row.trim()) rows.push(parseCsvRow(row));
      return rows;
    }
    let financialSnapshotInputsCache = null;
    async function loadFinancialSnapshotInputs() {
      if (financialSnapshotInputsCache !== null) return financialSnapshotInputsCache;
      const path = await findFinancialSnapshotInputsCsvPath();
      if (!path) { financialSnapshotInputsCache = {}; return financialSnapshotInputsCache; }
      try {
        const r = await fetch(path);
        const text = await r.text();
        const rows = parseCsvLines(text);
        const raw = {};
        for (let i = 1; i < rows.length; i++) {
          const row = rows[i];
          if (row.length >= 2) {
            const k = (row[0] || '').trim();
            const v = (row[1] || '').trim();
            if (k) raw[k] = v;
          }
        }
        const wealth = {};
        const wealthKeys = ['preTaxReturn', 'taxRate', 'costOfLiving', 'inflation', 'homeAppreciation', 'downsizeHouseYear', 'downsizeHouseAmount', 'downsizeCOLYear', 'downsizeCOLAmount'];
        wealthKeys.forEach(k => { if (raw[k] !== undefined) wealth[k] = String(raw[k]); });
        const monteCarlo = {};
        const mcMap = { mc_simulations: 'simulations', mc_returnVolatility: 'returnVolatility', mc_homeApprecVolatility: 'homeApprecVolatility', mc_inflationVolatility: 'inflationVolatility', mc_budgetVolatility: 'budgetVolatility', mc_inflationReturnCorr: 'inflationReturnCorr' };
        Object.entries(mcMap).forEach(([csvKey, internalKey]) => { if (raw[csvKey] !== undefined) monteCarlo[internalKey] = String(raw[csvKey]); });
        const balance = {};
        ['balance_exclude_realestate', 'balance_exclude_automobiles', 'balance_exclude_nonmerrill'].forEach(k => {
          if (raw[k] !== undefined) balance[k] = /^(true|1|yes)$/i.test(String(raw[k]).trim());
        });
        financialSnapshotInputsCache = { wealth, monteCarlo, balance };
        return financialSnapshotInputsCache;
      } catch (_) { financialSnapshotInputsCache = {}; return financialSnapshotInputsCache; }
    }
    async function saveCsvFile(filename, content) {
      if (window.electronAPI?.saveCsv) {
        const result = await window.electronAPI.saveCsv(filename, content);
        return;
      }
      const blob = new Blob([content], { type: 'text/csv;charset=utf-8' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      a.click();
      URL.revokeObjectURL(a.href);
    }
    function exportFinancialSnapshotInputsCsv() {
      const esc = (s) => (/[",\r\n]/.test(s) ? '"' + String(s).replace(/"/g, '""') + '"' : String(s));
      const el = id => document.getElementById(id);
      const wealth = wealthProjectionChart.getInputValues();
      const rows = [
        ['key', 'value'],
        ['preTaxReturn', wealth.preTaxReturn ?? ''],
        ['taxRate', wealth.taxRate ?? ''],
        ['costOfLiving', wealth.costOfLiving ?? ''],
        ['inflation', wealth.inflation ?? ''],
        ['homeAppreciation', wealth.homeAppreciation ?? ''],
        ['downsizeHouseYear', wealth.downsizeHouseYear ?? ''],
        ['downsizeHouseAmount', wealth.downsizeHouseAmount ?? ''],
        ['downsizeCOLYear', wealth.downsizeCOLYear ?? ''],
        ['downsizeCOLAmount', wealth.downsizeCOLAmount ?? ''],
        ['mc_simulations', el('mc-simulations')?.value ?? ''],
        ['mc_returnVolatility', el('mc-returnVolatility')?.value ?? ''],
        ['mc_homeApprecVolatility', el('mc-homeApprecVolatility')?.value ?? ''],
        ['mc_inflationVolatility', el('mc-inflationVolatility')?.value ?? ''],
        ['mc_budgetVolatility', el('mc-budgetVolatility')?.value ?? ''],
        ['mc_inflationReturnCorr', el('mc-inflationReturnCorr')?.value ?? ''],
        ['balance_exclude_realestate', (el('balance-exclude-realestate')?.checked ?? true) ? 'true' : 'false'],
        ['balance_exclude_automobiles', (el('balance-exclude-automobiles')?.checked ?? true) ? 'true' : 'false'],
        ['balance_exclude_nonmerrill', (el('balance-exclude-nonmerrill')?.checked ?? false) ? 'true' : 'false']
      ];
      const csv = rows.map(r => r.map(esc).join(',')).join('\r\n');
      saveCsvFile('financial-snapshot-inputs.csv', csv);
    }
    const BUDGET_CATEGORIES = [
      { grouping: 'Income', category: 'Rewards' }, { grouping: 'Income', category: 'Paychecks' }, { grouping: 'Income', category: 'Interest' }, { grouping: 'Income', category: 'Other Income' }, { grouping: 'Income', category: 'RSU Income' },
      { grouping: 'Gifts and Donations', category: 'Charity' }, { grouping: 'Gifts and Donations', category: 'Gifts' },
      { grouping: 'Auto and Transport', category: 'Gas' }, { grouping: 'Auto and Transport', category: 'Automotive Maintenance' }, { grouping: 'Auto and Transport', category: 'Auto Accident' }, { grouping: 'Auto and Transport', category: 'Parking' }, { grouping: 'Auto and Transport', category: 'Taxi and Ride Share' },
      { grouping: 'Home Maintenance', category: 'Property Taxes' }, { grouping: 'Home Maintenance', category: 'Insurance' }, { grouping: 'Home Maintenance', category: 'Home Improvement' }, { grouping: 'Home Maintenance', category: 'Misc Maintenance' }, { grouping: 'Home Maintenance', category: 'Pool Maintenance' }, { grouping: 'Home Maintenance', category: 'Gardening Maintenance' }, { grouping: 'Home Maintenance', category: 'Gallo Maintenance' },
      { grouping: 'Bills and Utilities', category: 'Power and Water' }, { grouping: 'Bills and Utilities', category: 'Phone' }, { grouping: 'Bills and Utilities', category: 'Internet' }, { grouping: 'Bills and Utilities', category: 'Subscriptions' }, { grouping: 'Bills and Utilities', category: 'Natural Gas' },
      { grouping: 'Food and Dining', category: 'Groceries' }, { grouping: 'Food and Dining', category: 'Restaurants' },
      { grouping: 'Travel & Entertainment', category: 'Travel' }, { grouping: 'Travel & Entertainment', category: 'Entertainment' }, { grouping: 'Travel & Entertainment', category: 'Airfare and Transportation' },
      { grouping: 'Shopping', category: 'Shopping' }, { grouping: 'Shopping', category: 'Clothing' }, { grouping: 'Shopping', category: 'Electronics' }, { grouping: 'Shopping', category: 'Postage and Shipping' },
      { grouping: 'Pets', category: 'Pet Food and Treats' }, { grouping: 'Pets', category: 'Pet Health' }, { grouping: 'Pets', category: 'Pet Wash' },
      { grouping: 'Children', category: 'Education' }, { grouping: 'Children', category: 'Child Activities' }, { grouping: 'Children', category: 'Kids Allowance' }, { grouping: 'Children', category: 'Tutoring' },
      { grouping: 'Health and Wellness', category: 'Health and Medical' }, { grouping: 'Health and Wellness', category: 'Personal Care' },
      { grouping: 'Rubin Household', category: 'Employee Wages' }, { grouping: 'Rubin Household', category: 'Employee Gifts' }, { grouping: 'Rubin Household', category: 'Cash and ATM' }, { grouping: 'Rubin Household', category: 'Employee Misc' },
      { grouping: 'Morgan Rose', category: 'Financial Services' }, { grouping: 'Morgan Rose', category: 'Business Services' },
      { grouping: 'Other', category: 'Categorized but not Budgeted' }
    ];
    const BUDGET_DEFAULT = 100000;
    const BUDGET_STORAGE_KEY = 'financial-snapshot-budget-limits';
    const IGNORED_CATEGORIES = [
      'Transfer', 'Rental Income', 'Rental Expense', 'Rental Maintenance',
      'Credit Card Payment', 'Balance Adjustment', 'Buy', 'Sell',
      'Income Taxes', 'Agnes Ambrus', 'Mortgage'
    ];
    const IGNORED_TAGS = ['1536 Rental'];
    function normalizeCategoryKey(s) {
      return (s || '').trim().toLowerCase().replace(/\s+/g, ' ').replace(/\s*&\s*/g, ' and ');
    }
    function resolveCategory(csvCategory) {
      const key = normalizeCategoryKey(csvCategory);
      if (IGNORED_CATEGORIES.some(ig => ig.toLowerCase() === key)) return null;
      return BUDGET_CATEGORIES.find(b => b.category.toLowerCase() === key)?.category || 'Categorized but not Budgeted';
    }
    function resolveBudgetCategory(csvCategory) {
      const key = normalizeCategoryKey(csvCategory);
      return BUDGET_CATEGORIES.find(b => b.category.toLowerCase() === key)?.category || null;
    }
    // Get a free key at https://fred.stlouisfed.org/docs/api/api_key.html — required for FRED data
    const FRED_API_KEY = 'bcee1688a7c679db8c1fc2cd60045012';
    const corsProxy = 'https://corsproxy.io/?';

    async function fetchFredObservations(seriesId, opts = {}) {
      if (!FRED_API_KEY) return null;
      const params = new URLSearchParams({ series_id: seriesId, api_key: FRED_API_KEY, file_type: 'json' });
      if (opts.sort_order) params.set('sort_order', opts.sort_order);
      if (opts.limit) params.set('limit', opts.limit);
      if (opts.observation_start) params.set('observation_start', opts.observation_start);
      if (opts.observation_end) params.set('observation_end', opts.observation_end);
      const url = 'https://api.stlouisfed.org/fred/series/observations?' + params;
      try {
        const r = await fetch(corsProxy + encodeURIComponent(url));
        const j = await r.json();
        return j?.observations?.filter(o => o.value !== '.') || [];
      } catch (_) { return null; }
    }

    // Shared helpers
    function parseDate(str) {
      const [m, d, y] = str.split('/').map(Number);
      return new Date(y, m - 1, d);
    }
    function parseDateIso(str) {
      const parts = str.split('-');
      if (parts.length !== 3) return new Date(NaN);
      const [y, m, d] = parts.map(Number);
      return new Date(y, m - 1, d);
    }

    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    function formatShortDate(dateStr) {
      const d = parseDate(dateStr);
      return monthNames[d.getMonth()] + ' ' + d.getDate();
    }

    function toYahooDate(d) {
      const y = d.getFullYear(), m = (d.getMonth() + 1).toString().padStart(2, '0'), day = d.getDate().toString().padStart(2, '0');
      return y + '-' + m + '-' + day;
    }

    function formatDateForCsv(d) {
      return (d.getMonth() + 1) + '/' + d.getDate() + '/' + d.getFullYear();
    }

    function movingAverage(values, window) {
      const result = [];
      for (let i = 0; i < values.length; i++) {
        if (i < window - 1) {
          result.push(null);
        } else {
          const slice = values.slice(i - window + 1, i + 1);
          result.push(slice.reduce((a, b) => a + b, 0) / window);
        }
      }
      return result;
    }

    // Chart registry: add charts here to show/hide or reorder
    const chartRegistry = {
      'balance': document.getElementById('chart-balance'),
      'key-figures': document.getElementById('chart-key-figures'),
      'wealth-projection': document.getElementById('chart-wealth-projection'),
      'wealth-montecarlo': document.getElementById('chart-wealth-montecarlo')
    };

    // Key figures: fetch CPI, Fed Funds Rate, TFDXX (uses CORS proxy for cross-origin)
    async function fetchKeyFigures() {
      const setCpi = v => { const el = document.getElementById('keyfig-cpi'); if (el) el.textContent = v; };
      const setFedFunds = v => { const el = document.getElementById('keyfig-fedfunds'); if (el) el.textContent = v; };
      const setTfdxx = v => { const el = document.getElementById('keyfig-tfdxx'); if (el) el.textContent = v; };
      const setLaHome = v => { const el = document.getElementById('keyfig-laHome'); if (el) el.textContent = v; };

      const blsUrl = 'https://api.bls.gov/publicAPI/v2/timeseries/data/CUSR0000SA0?startyear=2024&endyear=2026';
      try {
        const r = await fetch(corsProxy + encodeURIComponent(blsUrl));
        const j = await r.json();
        const data = j?.Results?.series?.[0]?.data?.filter(d => d.value && d.value !== '-') || [];
        if (data.length >= 2) {
          const latest = parseFloat(data[0].value);
          const prevYear = parseInt(data[0].year) - 1;
          const prev = data.find(d => d.period === data[0].period && parseInt(d.year) === prevYear);
          const yoy = prev ? ((latest - parseFloat(prev.value)) / parseFloat(prev.value) * 100).toFixed(2) + '%' : '—';
          setCpi(yoy);
        } else setCpi('—');
      } catch (_) { setCpi('—'); }

      let fedVal = null;
      if (FRED_API_KEY) {
        try {
          const fedUrl = 'https://api.stlouisfed.org/fred/series/observations?series_id=FEDFUNDS&api_key=' + FRED_API_KEY + '&file_type=json&sort_order=desc&limit=2';
          const r = await fetch(corsProxy + encodeURIComponent(fedUrl));
          const j = await r.json();
          const obs = j?.observations?.filter(o => o.value !== '.') || [];
          if (obs.length >= 1) fedVal = parseFloat(obs[0].value);
        } catch (_) {}
      }
      if (fedVal == null) {
        const fredFedUrl = 'https://fred.stlouisfed.org/data/FEDFUNDS.txt';
        const proxies = [
          { url: 'https://corsproxy.io/?', getText: r => r.text() },
          { url: 'https://api.allorigins.win/get?url=', getText: async r => { const j = await r.json(); return j?.contents || ''; } }
        ];
        let text = '';
        for (const p of proxies) {
          try {
            const r = await fetch(p.url + encodeURIComponent(fredFedUrl));
            text = await p.getText(r);
            if (text && text.length > 100) break;
          } catch (_) { continue; }
        }
        let pairs = [];
        const lineRe = /^(\d{4}-\d{2}-\d{2})\|([\d.,]+)/;
        for (const line of (text || '').split(/\r?\n/)) {
          const m = line.match(lineRe);
          if (m) {
            const v = parseFloat(m[2].replace(/,/g, ''));
            if (!isNaN(v) && m[2] !== '.') pairs.push([m[1], v]);
          }
        }
        if (pairs.length === 0) {
          const globalRe = /(\d{4}-\d{2}-\d{2})\|([\d.,]+)/g;
          let gm;
          while ((gm = globalRe.exec(text)) !== null) {
            const v = parseFloat(gm[2].replace(/,/g, ''));
            if (!isNaN(v) && gm[2] !== '.') pairs.push([gm[1], v]);
          }
        }
        if (pairs.length >= 1) fedVal = pairs[pairs.length - 1][1];
      }
      if (fedVal != null) setFedFunds(fedVal.toFixed(2) + '%');
      else setFedFunds('3.64%');

      const blkUrl = 'https://www.blackrock.com/cash/en-us/products/282628/blf-fedfund';
      try {
        const r = await fetch(corsProxy + encodeURIComponent(blkUrl));
        const html = await r.text();
        const m = html.match(/7\s*Day\s*SEC\s*Yield[^%]*?([\d.]+)\s*%/i);
        setTfdxx(m ? m[1] + '%' : '—');
      } catch (_) { setTfdxx('—'); }

      try {
        let latestVal = null, yearAgoVal = null;
        const obs = await fetchFredObservations('LXXRSA', { sort_order: 'desc', limit: 24 });
        if (obs && obs.length >= 1) {
          latestVal = parseFloat(obs[0].value);
          const [y, m] = obs[0].date.split('-').map(Number);
          const yearAgoKey = (y - 1) + '-' + String(m).padStart(2, '0');
          const yearAgo = obs.find(o => o.date.startsWith(yearAgoKey));
          if (yearAgo) yearAgoVal = parseFloat(yearAgo.value);
        }
        if (latestVal != null && yearAgoVal != null && yearAgoVal > 0) {
          setLaHome((((latestVal / yearAgoVal) - 1) * 100).toFixed(2) + '%');
        } else {
          const fredLaUrl = 'https://fred.stlouisfed.org/data/LXXRSA.txt';
          const proxies = [{ url: 'https://corsproxy.io/?', getText: r => r.text() }, { url: 'https://api.allorigins.win/get?url=', getText: async r => { const j = await r.json(); return j?.contents || ''; } }];
          let text = '';
          for (const p of proxies) {
            try {
              const r = await fetch(p.url + encodeURIComponent(fredLaUrl));
              text = await p.getText(r);
              if (text && text.length > 100) break;
            } catch (_) { continue; }
          }
          const res = [
            /(\d{4}-\d{2}-\d{2})<\/td>\s*<td[^>]*>([\d.,]+)/gi,
            /(\d{4}-\d{2}-\d{2})[\s|>]+([\d.,]+)/g
          ];
          const map = new Map();
          for (const re of res) {
            re.lastIndex = 0;
            let m;
            while ((m = re.exec(text)) !== null) {
              const v = parseFloat(m[2].replace(/,/g, ''));
              if (!isNaN(v) && m[2] !== '.') map.set(m[1], v);
            }
            if (map.size > 0) break;
          }
          const dates = [...map.keys()].sort();
          if (dates.length >= 1) {
            const latestDate = dates[dates.length - 1];
            latestVal = map.get(latestDate);
            const [y, mo] = latestDate.split('-').map(Number);
            const yearAgoPrefix = (y - 1) + '-' + String(mo).padStart(2, '0');
            yearAgoVal = map.get(yearAgoPrefix + '-01') ?? map.get(yearAgoPrefix + '-15') ?? [...map.entries()].find(([d]) => d.startsWith(yearAgoPrefix))?.[1];
            if (latestVal != null && yearAgoVal != null && yearAgoVal > 0) {
              setLaHome((((latestVal / yearAgoVal) - 1) * 100).toFixed(2) + '%');
            } else setLaHome('—');
          } else setLaHome('—');
        }
      } catch (_) { setLaHome('—'); }
    }

    function normalRandom(mean, stdDev) {
      const u1 = Math.random(), u2 = Math.random();
      if (u1 < 1e-10) return mean;
      const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
      return mean + z * stdDev;
    }

    function percentile(arr, p) {
      const sorted = [...arr].sort((a, b) => a - b);
      const idx = (p / 100) * (sorted.length - 1);
      const lo = Math.floor(idx), hi = Math.ceil(idx);
      return lo === hi ? sorted[lo] : sorted[lo] + (idx - lo) * (sorted[hi] - sorted[lo]);
    }

    function setChartVisible(chartId, visible) {
      const el = chartRegistry[chartId];
      if (el) el.setAttribute('data-visible', visible);
    }

    function isChartVisible(chartId) {
      return chartRegistry[chartId]?.getAttribute('data-visible') !== 'false';
    }

    // Net Investments chart
    const netInvestmentsChart = {
      id: 'net-investments',
      instance: null,
      rawData: [],

      filterData(view) {
        const d = this.rawData;
        if (view === '1month') {
          const latest = d[d.length - 1]?.dateObj;
          if (!latest) return { labels: [], values: [], dateObjs: [] };
          const cutoff = new Date(latest);
          cutoff.setMonth(cutoff.getMonth() - 1);
          const filtered = d.filter(r => r.dateObj >= cutoff);
          return { labels: filtered.map(r => formatShortDate(r.dateStr)), values: filtered.map(r => r.value), dateObjs: filtered.map(r => r.dateObj) };
        } else if (view === '90days') {
          const latest = d[d.length - 1]?.dateObj;
          if (!latest) return { labels: [], values: [], dateObjs: [] };
          const cutoff = new Date(latest);
          cutoff.setDate(cutoff.getDate() - 90);
          const filtered = d.filter(r => r.dateObj >= cutoff);
          return { labels: filtered.map(r => formatShortDate(r.dateStr)), values: filtered.map(r => r.value), dateObjs: filtered.map(r => r.dateObj) };
        } else {
          const latest = d[d.length - 1]?.dateObj;
          if (!latest) return { labels: [], values: [], dateObjs: [] };
          const yearStart = new Date(latest.getFullYear(), 0, 1);
          const filtered = d.filter(r => r.dateObj >= yearStart && r.dateObj.getDay() === 6);
          return { labels: filtered.map(r => formatShortDate(r.dateStr)), values: filtered.map(r => r.value), dateObjs: filtered.map(r => r.dateObj) };
        }
      },

      sp500Cache: null,
      parseFredSp500(text) {
        const map = new Map();
        const re = /(?:^|[^0-9])(\d{4}-\d{2}-\d{2})\|([\d,.]+)/g;
        let m;
        while ((m = re.exec(text)) !== null) {
          const date = m[1];
          const valStr = m[2].replace(/,/g, '').trim();
          if (valStr === '.' || valStr === '') continue;
          const v = parseFloat(valStr);
          if (!isNaN(v)) map.set(date, v);
        }
        return map;
      },
      async fetchSp500Cache() {
        if (this.sp500Cache && this.sp500Cache.size > 0) return this.sp500Cache;
        const start = new Date();
        start.setFullYear(start.getFullYear() - 2);
        const obs = await fetchFredObservations('SP500', { observation_start: start.toISOString().slice(0, 10), sort_order: 'asc' });
        if (obs && obs.length > 0) {
          this.sp500Cache = new Map(obs.map(o => [o.date, parseFloat(o.value)]));
          return this.sp500Cache;
        }
        const fredUrl = 'https://fred.stlouisfed.org/data/SP500.txt';
        const proxies = ['https://corsproxy.io/?', 'https://api.allorigins.win/get?url='];
        for (const proxy of proxies) {
          try {
            const r = await fetch(proxy + encodeURIComponent(fredUrl));
            const text = proxy.includes('allorigins') ? ((await r.json())?.contents || '') : await r.text();
            if (text && (text.includes('DATE') || text.includes('SP500'))) {
              const map = this.parseFredSp500(text);
              if (map.size > 0) { this.sp500Cache = map; return this.sp500Cache; }
            }
          } catch (_) { continue; }
        }
        this.sp500Cache = new Map();
        return this.sp500Cache;
      },

      alignSp500(dateObjs) {
        if (!this.sp500Cache || this.sp500Cache.size === 0) return null;
        const lookup = (d) => {
          for (let i = 0; i < 10; i++) {
            const t = new Date(d);
            t.setDate(t.getDate() - i);
            const v = this.sp500Cache.get(toYahooDate(t));
            if (v != null) return v;
          }
          return null;
        };
        const vals = dateObjs.map(d => lookup(d));
        let last = vals.find(v => v != null);
        for (let i = 0; i < vals.length; i++) {
          if (vals[i] != null) last = vals[i];
          else vals[i] = last;
        }
        return vals.every(v => v != null) ? vals : null;
      },

      async update(view) {
        const { labels, values, dateObjs } = this.filterData(view);
        const maWindow = (view === '1month' || view === '90days') ? 7 : 4;
        const maValues = movingAverage(values, maWindow);
        await this.fetchSp500Cache();
        const sp500Values = this.alignSp500(dateObjs);

        const base = values[0] || 1;
        const netPct = values.map(v => ((v / base) - 1) * 100);
        const maPct = maValues.map(v => v != null ? ((v / base) - 1) * 100 : null);
        const goalPct = ((45000000 / base) - 1) * 100;
        const goalLine = labels.map(() => goalPct);
        const sp500Pct = sp500Values ? sp500Values.map(v => v != null ? ((v / sp500Values[0]) - 1) * 100 : null) : null;

        const allPct = [...netPct.filter(Boolean), ...(sp500Pct || []).filter(Boolean)];
        const pad = 1.5;
        const pctMinRaw = allPct.length ? Math.min(0, ...allPct) - pad : -5;
        const pctMaxRaw = allPct.length ? Math.max(0, ...allPct) + pad : 5;
        const pctMin = Math.round(pctMinRaw * 10) / 10;
        const pctMax = Math.round(pctMaxRaw * 10) / 10;
        const dollarMin = base * (1 + pctMin / 100);
        const dollarMax = base * (1 + pctMax / 100);

        if (this.instance) {
          this.instance.rawNetInv = values;
          this.instance.rawSp500 = sp500Values;
          this.instance.dateObjs = dateObjs;
          this.instance.data.labels = labels;
          this.instance.data.datasets[0].data = netPct;
          this.instance.data.datasets[1].data = maPct;
          this.instance.data.datasets[2].data = goalLine;
          this.instance.data.datasets[3].data = sp500Pct || labels.map(() => null);
          this.instance.data.datasets[3].borderColor = sp500Pct ? '#ef4444' : 'transparent';
          this.instance.options.scales.y.min = pctMin;
          this.instance.options.scales.y.max = pctMax;
          this.instance.options.scales.y1.min = dollarMin;
          this.instance.options.scales.y1.max = dollarMax;
          this.instance.update();
          this.renderDataBreakdown();
        }
      },

      renderDataBreakdown() {
        const el = document.getElementById('netinv-data-breakdown');
        if (!el || !this.instance) return;
        const labels = this.instance.data.labels || [];
        const rawNet = this.instance.rawNetInv || [];
        const rawSp = this.instance.rawSp500 || [];
        const dateObjs = this.instance.dateObjs || [];
        const fmt = (d) => d ? monthNames[d.getMonth()] + ' ' + d.getDate() + ', ' + d.getFullYear() : '';
        const fmtDollar = n => n != null ? '$' + Math.round(n).toLocaleString() : '—';
        const fmtSp = n => n != null ? n.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : '—';
        const rows = labels.map((lab, i) => ({
          date: fmt(dateObjs[i]) || lab,
          netInv: fmtDollar(rawNet[i]),
          sp500: fmtSp(rawSp[i])
        }));
        el.innerHTML = '<table class="breakdown-table"><thead><tr><th>Date</th><th>Net Investment</th><th>S&P 500</th></tr></thead><tbody>' +
          rows.map(r => `<tr><td>${r.date}</td><td>${r.netInv}</td><td>${r.sp500}</td></tr>`).join('') + '</tbody></table>';
      },

      show() { setChartVisible(this.id, true); },
      hide() { setChartVisible(this.id, false); },

      extendRawDataToToday() {
        if (this.rawData.length === 0) return;
        const last = this.rawData[this.rawData.length - 1];
        const lastDate = new Date(last.dateObj.getFullYear(), last.dateObj.getMonth(), last.dateObj.getDate());
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const oneDay = 24 * 60 * 60 * 1000;
        let d = new Date(lastDate.getTime() + oneDay);
        while (d <= today) {
          const dateStr = formatDateForCsv(d);
          this.rawData.push({
            dateStr,
            dateObj: new Date(d),
            value: last.value,
            rawRow: [dateStr, last.rawRow[1], last.rawRow[2], last.rawRow[3], last.rawRow[4]]
          });
          d.setTime(d.getTime() + oneDay);
        }
      },

      getExtendedCsvContent() {
        if (this.rawData.length === 0) return '';
        const header = 'Date,Net worth,Real Estate,Vehicles,Net Investments';
        const rows = this.rawData.map(r => r.rawRow.join(','));
        return header + '\n' + rows.join('\n');
      },

      async saveToCsv() {
        if (this.rawData.length === 0) return;
        const csv = this.getExtendedCsvContent();
        try {
          if ('showOpenFilePicker' in window) {
            const [handle] = await window.showOpenFilePicker({
              types: [{ description: 'CSV files', accept: { 'text/csv': ['.csv'] } }],
              mode: 'readwrite'
            });
            const writable = await handle.createWritable();
            await writable.write(csv);
            await writable.close();
            return;
          }
        } catch (e) {
          if (e.name === 'AbortError') return;
        }
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'net-investments-extended.csv';
        a.click();
        URL.revokeObjectURL(a.href);
      },

      async init() {
        const invFilters = { realEstate: true, automobiles: true, nonMerrill: false };
        const byDate = new Map();
        for (const r of balanceChart.rawRows) {
          if (balanceChart.isExcluded(r.account, invFilters)) continue;
          byDate.set(r.dateStr, (byDate.get(r.dateStr) || 0) + r.value);
        }
        this.rawData = Array.from(byDate.entries())
          .map(([dateStr, value]) => ({ dateStr, dateObj: parseDateIso(dateStr), value, rawRow: [dateStr, '', '', '', String(value)] }))
          .filter(r => !isNaN(r.dateObj.getTime()))
          .sort((a, b) => a.dateObj - b.dateObj);
        this.extendRawDataToToday();

        const view = document.getElementById('netInvestments-viewSelect').value;
        const { labels, values, dateObjs } = this.filterData(view);
        const maWindow = (view === '1month' || view === '90days') ? 7 : 4;
        const maValues = movingAverage(values, maWindow);
        await this.fetchSp500Cache();
        const sp500Values = this.alignSp500(dateObjs);

        const base = values[0] || 1;
        const netPct = values.map(v => ((v / base) - 1) * 100);
        const maPct = maValues.map(v => v != null ? ((v / base) - 1) * 100 : null);
        const goalPct = ((45000000 / base) - 1) * 100;
        const goalLine = labels.map(() => goalPct);
        const sp500Pct = sp500Values ? sp500Values.map(v => v != null ? ((v / sp500Values[0]) - 1) * 100 : null) : null;

        const allPct = [...netPct.filter(Boolean), ...(sp500Pct || []).filter(Boolean)];
        const pad = 1.5;
        const pctMinRaw = allPct.length ? Math.min(0, ...allPct) - pad : -5;
        const pctMaxRaw = allPct.length ? Math.max(0, ...allPct) + pad : 5;
        const pctMin = Math.round(pctMinRaw * 10) / 10;
        const pctMax = Math.round(pctMaxRaw * 10) / 10;
        const dollarMin = base * (1 + pctMin / 100);
        const dollarMax = base * (1 + pctMax / 100);

        const ctx = document.getElementById('netInvestments-canvas').getContext('2d');
        this.instance = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [{
            data: netPct,
            yAxisID: 'y',
            borderColor: '#0ea5e9',
            backgroundColor: 'rgba(14, 165, 233, 0.2)',
            fill: true,
            tension: 0.3,
            pointRadius: 3,
            pointHoverRadius: 8,
            pointBackgroundColor: '#0ea5e9',
            borderWidth: 4,
          }, {
            data: maPct,
            yAxisID: 'y',
            borderColor: 'rgba(14, 165, 233, 0.5)',
            fill: false,
            tension: 0.3,
            pointRadius: 0,
            pointHoverRadius: 0,
            borderWidth: 2,
          }, {
            data: goalLine,
            yAxisID: 'y',
            borderColor: '#22c55e',
            fill: false,
            tension: 0,
            pointRadius: 0,
            pointHoverRadius: 0,
            borderWidth: 4,
          }, {
            data: sp500Pct || labels.map(() => null),
            yAxisID: 'y',
            borderColor: sp500Pct ? '#ef4444' : 'transparent',
            fill: false,
            tension: 0.3,
            pointRadius: 0,
            pointHoverRadius: 4,
            borderWidth: 3,
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          layout: { padding: 6 },
          plugins: {
            legend: { display: false },
            tooltip: {
              filter: (item) => item.datasetIndex === 0 || item.datasetIndex === 3,
              animation: { duration: 0 },
              callbacks: {
                label: (ctx) => {
                  const rawNet = ctx.chart.rawNetInv?.[ctx.dataIndex];
                  const rawSp = ctx.chart.rawSp500?.[ctx.dataIndex];
                  const baseSp = ctx.chart.rawSp500?.[0];
                  if (ctx.datasetIndex === 0 && rawNet != null) return 'Net Investments: $' + rawNet.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
                  if (ctx.datasetIndex === 3 && rawSp != null && baseSp) {
                    const pct = ((rawSp / baseSp) - 1) * 100;
                    const sign = pct >= 0 ? '+' : '';
                    return 'S&P 500: ' + rawSp.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + ' (' + sign + pct.toFixed(1) + '%)';
                  }
                  return '';
                }
              }
            },
          },
          scales: {
            x: {
              title: { display: false },
              grid: { display: false },
              ticks: { color: '#555', font: { size: 11 } },
            },
            y: {
              type: 'linear',
              position: 'left',
              min: pctMin,
              max: pctMax,
              title: { display: true, text: '% return', color: '#555', font: { size: 11 } },
              grid: { color: 'rgba(0,0,0,0.08)' },
              ticks: {
                color: '#555',
                font: { size: 11 },
                callback: (value) => value != null ? Number(value).toFixed(1) + '%' : ''
              }
            },
            y1: {
              type: 'linear',
              position: 'right',
              min: dollarMin,
              max: dollarMax,
              title: { display: true, text: 'Net Investments ($M)', color: '#555', font: { size: 11 } },
              grid: { drawOnChartArea: false },
              ticks: {
                color: '#555',
                font: { size: 11 },
                callback: (value) => value != null ? '$' + Math.round(value / 1000000) + 'm' : ''
              }
            }
          }
        }
      });
        this.instance.rawNetInv = values;
        this.instance.rawSp500 = sp500Values;
        this.instance.dateObjs = dateObjs;
        this.renderDataBreakdown();

        document.getElementById('netInvestments-viewSelect').addEventListener('change', (e) => {
          this.update(e.target.value);
        });
        document.getElementById('netInvestments-saveCsv').addEventListener('click', () => {
          this.saveToCsv();
        });
      }
    };

    // Balance chart (sum of all accounts per day from Balances.csv)
    const balanceChart = {
      id: 'balance',
      instance: null,
      rawRows: [],

      getExclusionFilters() {
        return {
          realEstate: document.getElementById('balance-exclude-realestate')?.checked ?? true,
          automobiles: document.getElementById('balance-exclude-automobiles')?.checked ?? true,
          nonMerrill: document.getElementById('balance-exclude-nonmerrill')?.checked ?? false
        };
      },

      isExcluded(account, filters) {
        if (!account) return false;
        const a = account;
        if (filters.realEstate && (a.includes('1540 Skylark Lane') || a.includes('1536 Skylark Lane'))) return true;
        if (filters.automobiles) {
          const lower = a.toLowerCase();
          if (lower.includes('porsche') || lower.includes('ferrari') || lower.includes('range rover')) return true;
        }
        if (filters.nonMerrill && !a.includes('Merrill')) {
          if (a.includes('Bank of America Mortgage')) return false;
          return true;
        }
        return false;
      },

      extendToToday(result, view) {
        const { labels, values, dateObjs } = result;
        if (labels.length === 0) return result;
        const last = new Date(dateObjs[dateObjs.length - 1]);
        last.setHours(0, 0, 0, 0);
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        if (last >= today) return result;
        const newLabels = [...labels];
        const newValues = [...values];
        const newDateObjs = [...dateObjs];
        const dayMs = 24 * 60 * 60 * 1000;
        let d = new Date(last.getTime() + dayMs);
        while (d <= today) {
          const add = (view === 'year' && d.getDay() === 6) || (view === 'lifetime' && d.getDay() === 6) || (view === '1month' || view === '90days');
          if (add) {
            newLabels.push(view === 'lifetime' ? monthNames[d.getMonth()] + ' ' + d.getDate() + ', ' + d.getFullYear() : monthNames[d.getMonth()] + ' ' + d.getDate());
            newValues.push(null);
            newDateObjs.push(new Date(d));
          }
          d.setTime(d.getTime() + dayMs);
        }
        return { labels: newLabels, values: newValues, dateObjs: newDateObjs };
      },

      getFilteredDailyTotals() {
        const filters = this.getExclusionFilters();
        const byDate = new Map();
        for (const r of this.rawRows) {
          if (this.isExcluded(r.account, filters)) continue;
          const key = r.dateStr;
          byDate.set(key, (byDate.get(key) || 0) + r.value);
        }
        return Array.from(byDate.entries())
          .map(([dateStr, value]) => ({ dateStr, dateObj: parseDateIso(dateStr), value }))
          .filter(r => !isNaN(r.dateObj.getTime()))
          .sort((a, b) => a.dateObj - b.dateObj);
      },

      isRealEstateAccount(account) {
        if (!account) return false;
        const a = account;
        return a.includes('Skylark') || a.includes('BLKSTN - Real Estate') || a.includes('Mortgage');
      },

      getRealEstateDailyTotals() {
        const byDate = new Map();
        for (const r of this.rawRows) {
          if (!this.isRealEstateAccount(r.account)) continue;
          const key = r.dateStr;
          byDate.set(key, (byDate.get(key) || 0) + r.value);
        }
        return Array.from(byDate.entries())
          .map(([dateStr, value]) => ({ dateStr, dateObj: parseDateIso(dateStr), value }))
          .filter(r => !isNaN(r.dateObj.getTime()))
          .sort((a, b) => a.dateObj - b.dateObj);
      },

      getLatestForProjection() {
        const invFilters = { realEstate: true, automobiles: true, nonMerrill: false };
        const byDateInv = new Map();
        for (const r of this.rawRows) {
          if (this.isExcluded(r.account, invFilters)) continue;
          byDateInv.set(r.dateStr, (byDateInv.get(r.dateStr) || 0) + r.value);
        }
        const invEntries = Array.from(byDateInv.entries()).sort((a, b) => parseDateIso(a[0]) - parseDateIso(b[0]));
        const reTotals = this.getRealEstateDailyTotals();
        const latestDate = invEntries.length ? invEntries[invEntries.length - 1][0] : null;
        const netInvestments = latestDate ? byDateInv.get(latestDate) || 0 : 0;
        const reForDate = reTotals.find(r => r.dateStr === latestDate);
        const realEstate = reForDate ? reForDate.value : 0;
        return { netInvestments, realEstate };
      },

      filterData(view) {
        const d = this.getFilteredDailyTotals();
        if (view === '1month') {
          const latest = d[d.length - 1]?.dateObj;
          if (!latest) return { labels: [], values: [], dateObjs: [] };
          const cutoff = new Date(latest);
          cutoff.setMonth(cutoff.getMonth() - 1);
          const filtered = d.filter(r => r.dateObj >= cutoff);
          return this.extendToToday({ labels: filtered.map(r => monthNames[r.dateObj.getMonth()] + ' ' + r.dateObj.getDate()), values: filtered.map(r => r.value), dateObjs: filtered.map(r => r.dateObj) }, view);
        } else if (view === '90days') {
          const latest = d[d.length - 1]?.dateObj;
          if (!latest) return { labels: [], values: [], dateObjs: [] };
          const cutoff = new Date(latest);
          cutoff.setDate(cutoff.getDate() - 90);
          const filtered = d.filter(r => r.dateObj >= cutoff);
          return this.extendToToday({ labels: filtered.map(r => monthNames[r.dateObj.getMonth()] + ' ' + r.dateObj.getDate()), values: filtered.map(r => r.value), dateObjs: filtered.map(r => r.dateObj) }, view);
        } else if (view === 'lifetime') {
          if (d.length === 0) return { labels: [], values: [], dateObjs: [] };
          const filtered = d.filter(r => r.dateObj.getDay() === 6);
          return this.extendToToday({ labels: filtered.map(r => monthNames[r.dateObj.getMonth()] + ' ' + r.dateObj.getDate() + ', ' + r.dateObj.getFullYear()), values: filtered.map(r => r.value), dateObjs: filtered.map(r => r.dateObj) }, view);
        } else {
          const latest = d[d.length - 1]?.dateObj;
          if (!latest) return { labels: [], values: [], dateObjs: [] };
          const yearStart = new Date(latest.getFullYear(), 0, 1);
          const filtered = d.filter(r => r.dateObj >= yearStart && r.dateObj.getDay() === 6);
          return this.extendToToday({ labels: filtered.map(r => monthNames[r.dateObj.getMonth()] + ' ' + r.dateObj.getDate()), values: filtered.map(r => r.value), dateObjs: filtered.map(r => r.dateObj) }, view);
        }
      },

      renderDataBreakdown() {
        const el = document.getElementById('balance-data-breakdown');
        if (!el || !this.instance) return;
        const labels = this.instance.data.labels || [];
        const rawVals = this.instance.rawBalance || [];
        const rawSp = this.instance.rawSp500 || [];
        const dateObjs = this.instance.dateObjs || [];
        const fmt = (d) => d ? monthNames[d.getMonth()] + ' ' + d.getDate() + ', ' + d.getFullYear() : '';
        const fmtDollar = n => n != null ? '$' + Math.round(n).toLocaleString() : '—';
        const fmtSp = n => n != null ? n.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : '—';
        const rows = labels.map((lab, i) => ({ date: fmt(dateObjs[i]) || lab, balance: fmtDollar(rawVals[i]), sp500: fmtSp(rawSp?.[i]) }));
        el.innerHTML = '<table class="breakdown-table"><thead><tr><th>Date</th><th>Balance</th><th>S&P 500</th></tr></thead><tbody>' +
          rows.map(r => `<tr><td>${r.date}</td><td>${r.balance}</td><td>${r.sp500}</td></tr>`).join('') + '</tbody></table>';
      },

      async update(view) {
        const { labels, values, dateObjs } = this.filterData(view);
        const maWindow = (view === '1month' || view === '90days') ? 7 : 4;
        const maValues = movingAverage(values, maWindow);
        await netInvestmentsChart.fetchSp500Cache();
        let sp500Values = netInvestmentsChart.alignSp500(dateObjs);
        if (sp500Values && values.some((v, i) => v == null && i > 0)) {
          sp500Values = sp500Values.map((v, i) => values[i] == null ? null : v);
        }

        const base = values.find(v => v != null) || 1;
        const balPct = values.map(v => v != null ? ((v / base) - 1) * 100 : null);
        const maPct = maValues.map(v => v != null ? ((v / base) - 1) * 100 : null);
        const sp500Pct = sp500Values ? sp500Values.map(v => v != null ? ((v / sp500Values[0]) - 1) * 100 : null) : null;

        const allPct = [...balPct.filter(Boolean), ...(sp500Pct || []).filter(Boolean)];
        const pad = 1.5;
        const pctMinRaw = allPct.length ? Math.min(0, ...allPct) - pad : -5;
        const pctMaxRaw = allPct.length ? Math.max(0, ...allPct) + pad : 5;
        const pctMin = Math.round(pctMinRaw * 10) / 10;
        const pctMax = Math.round(pctMaxRaw * 10) / 10;
        const dollarMin = base * (1 + pctMin / 100);
        const dollarMax = base * (1 + pctMax / 100);

        if (this.instance) {
          this.instance.rawBalance = values;
          this.instance.rawSp500 = sp500Values;
          this.instance.dateObjs = dateObjs;
          this.instance.data.labels = labels;
          this.instance.data.datasets[0].data = balPct;
          this.instance.data.datasets[1].data = maPct;
          this.instance.data.datasets[2].data = sp500Pct || labels.map(() => null);
          this.instance.data.datasets[2].borderColor = sp500Pct ? '#ef4444' : 'transparent';
          this.instance.options.scales.y.min = pctMin;
          this.instance.options.scales.y.max = pctMax;
          this.instance.options.scales.y1.min = dollarMin;
          this.instance.options.scales.y1.max = dollarMax;
          this.instance.update();
          this.renderDataBreakdown();
        }
      },

      async init() {
        const balancesCsvPath = await findBalancesCsvPath();
        const response = await fetch(balancesCsvPath);
        const text = await response.text();
        const lines = text.trim().split('\n');
        const rows = lines.slice(1).filter(line => line.trim());

        this.rawRows = [];
        for (const line of rows) {
          const cols = line.split(',');
          const dateStr = cols[0]?.trim();
          const balance = parseFloat(cols[1]) || 0;
          const account = (cols.slice(2).join(',') || '').trim();
          if (!dateStr || dateStr === 'Date') continue;
          this.rawRows.push({ dateStr, dateObj: parseDateIso(dateStr), account, value: balance });
        }
        this.rawRows = this.rawRows.filter(r => !isNaN(r.dateObj.getTime())).sort((a, b) => a.dateObj - b.dateObj || a.account.localeCompare(b.account));

        const view = document.getElementById('balance-viewSelect')?.value || '1month';
        const { labels, values, dateObjs } = this.filterData(view);
        const maWindow = (view === '1month' || view === '90days') ? 7 : 4;
        const maValues = movingAverage(values, maWindow);
        await netInvestmentsChart.fetchSp500Cache();
        let sp500Values = netInvestmentsChart.alignSp500(dateObjs);
        if (sp500Values && values.some((v, i) => v == null && i > 0)) {
          sp500Values = sp500Values.map((v, i) => values[i] == null ? null : v);
        }

        const base = values.find(v => v != null) || 1;
        const balPct = values.map(v => v != null ? ((v / base) - 1) * 100 : null);
        const maPct = maValues.map(v => v != null ? ((v / base) - 1) * 100 : null);
        const sp500Pct = sp500Values ? sp500Values.map(v => v != null ? ((v / sp500Values[0]) - 1) * 100 : null) : null;

        const allPct = [...balPct.filter(Boolean), ...(sp500Pct || []).filter(Boolean)];
        const pad = 1.5;
        const pctMinRaw = allPct.length ? Math.min(0, ...allPct) - pad : -5;
        const pctMaxRaw = allPct.length ? Math.max(0, ...allPct) + pad : 5;
        const pctMin = Math.round(pctMinRaw * 10) / 10;
        const pctMax = Math.round(pctMaxRaw * 10) / 10;
        const dollarMin = base * (1 + pctMin / 100);
        const dollarMax = base * (1 + pctMax / 100);

        const ctx = document.getElementById('balance-canvas').getContext('2d');
        this.instance = new Chart(ctx, {
          type: 'line',
          data: {
            labels,
            datasets: [{
              data: balPct,
              yAxisID: 'y',
              spanGaps: false,
              borderColor: '#0ea5e9',
              backgroundColor: 'rgba(14, 165, 233, 0.2)',
              fill: true,
              tension: 0.3,
              pointRadius: 3,
              pointHoverRadius: 8,
              pointBackgroundColor: '#0ea5e9',
              borderWidth: 4,
            }, {
              data: maPct,
              yAxisID: 'y',
              spanGaps: false,
              borderColor: 'rgba(14, 165, 233, 0.5)',
              fill: false,
              tension: 0.3,
              pointRadius: 0,
              pointHoverRadius: 0,
              borderWidth: 2,
            }, {
              data: sp500Pct || labels.map(() => null),
              yAxisID: 'y',
              spanGaps: false,
              borderColor: sp500Pct ? '#ef4444' : 'transparent',
              fill: false,
              tension: 0.3,
              pointRadius: 0,
              pointHoverRadius: 4,
              borderWidth: 3,
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            layout: { padding: 6 },
            plugins: {
              legend: { display: false },
              tooltip: {
                filter: (item) => item.datasetIndex === 0 || item.datasetIndex === 2,
                animation: { duration: 0 },
                callbacks: {
                  label: (ctx) => {
                    const rawBal = ctx.chart.rawBalance?.[ctx.dataIndex];
                    const rawSp = ctx.chart.rawSp500?.[ctx.dataIndex];
                    const baseSp = ctx.chart.rawSp500?.[0];
                    if (ctx.datasetIndex === 0 && rawBal != null) return 'Balance: $' + rawBal.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
                    if (ctx.datasetIndex === 2 && rawSp != null && baseSp) {
                      const pct = ((rawSp / baseSp) - 1) * 100;
                      const sign = pct >= 0 ? '+' : '';
                      return 'S&P 500: ' + rawSp.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + ' (' + sign + pct.toFixed(1) + '%)';
                    }
                    return '';
                  }
                }
              },
            },
            scales: {
              x: { title: { display: false }, grid: { display: false }, ticks: { color: '#555', font: { size: 11 } } },
              y: {
                type: 'linear',
                position: 'left',
                min: pctMin,
                max: pctMax,
                title: { display: true, text: '% return', color: '#555', font: { size: 11 } },
                grid: { color: 'rgba(0,0,0,0.08)' },
                ticks: { color: '#555', font: { size: 11 }, callback: (value) => value != null ? Number(value).toFixed(1) + '%' : '' }
              },
              y1: {
                type: 'linear',
                position: 'right',
                min: dollarMin,
                max: dollarMax,
                title: { display: true, text: 'Balance ($M)', color: '#555', font: { size: 11 } },
                grid: { drawOnChartArea: false },
                ticks: { color: '#555', font: { size: 11 }, callback: (value) => value != null ? '$' + Math.round(value / 1000000) + 'm' : '' }
              }
            }
          }
        });
        this.instance.rawBalance = values;
        this.instance.rawSp500 = sp500Values;
        this.instance.dateObjs = dateObjs;
        this.renderDataBreakdown();

        document.getElementById('balance-viewSelect')?.addEventListener('change', (e) => {
          this.update(e.target.value);
        });
        ['balance-exclude-realestate', 'balance-exclude-automobiles', 'balance-exclude-nonmerrill'].forEach(id => {
          document.getElementById(id)?.addEventListener('change', () => {
            const view = document.getElementById('balance-viewSelect')?.value || '1month';
            this.update(view);
          });
        });
      }
    };

    // Wealth Projection chart
    const wealthProjectionDefaults = {
      preTaxReturn: '7.30',
      taxRate: '30.00',
      costOfLiving: '1500000',
      inflation: '3.0',
      homeAppreciation: '3',
      downsizeHouseYear: '2037',
      downsizeHouseAmount: '10000000',
      downsizeCOLYear: '2037',
      downsizeCOLAmount: '-200000'
    };
    const WEALTH_STORAGE_KEY = 'financial-snapshot-wealth-inputs';

    const wealthProjectionChart = {
      id: 'wealth-projection',
      instance: null,
      startYear: 2026,
      numYears: 41,

      loadStored() {
        try {
          const stored = localStorage.getItem(WEALTH_STORAGE_KEY);
          return stored ? JSON.parse(stored) : null;
        } catch { return null; }
      },

      saveToStorage() {
        const vals = this.getInputValues();
        try { localStorage.setItem(WEALTH_STORAGE_KEY, JSON.stringify(vals)); } catch (_) {}
      },

      getInputValues() {
        return {
          preTaxReturn: document.getElementById('wealth-preTaxReturn')?.value ?? '7.30',
          taxRate: document.getElementById('wealth-taxRate')?.value ?? '30.00',
          costOfLiving: document.getElementById('wealth-costOfLiving')?.value ?? '1500000',
          inflation: document.getElementById('wealth-inflation')?.value ?? '3.0',
          homeAppreciation: document.getElementById('wealth-homeAppreciation')?.value ?? '3',
          downsizeHouseYear: document.getElementById('wealth-downsizeHouseYear')?.value ?? '2037',
          downsizeHouseAmount: document.getElementById('wealth-downsizeHouseAmount')?.value ?? '10000000',
          downsizeCOLYear: document.getElementById('wealth-downsizeCOLYear')?.value ?? '2037',
          downsizeCOLAmount: document.getElementById('wealth-downsizeCOLAmount')?.value ?? '-200000'
        };
      },

      setInputValues(vals) {
        const merged = { ...wealthProjectionDefaults, ...vals };
        const ids = ['wealth-preTaxReturn','wealth-taxRate','wealth-costOfLiving','wealth-inflation','wealth-homeAppreciation','wealth-downsizeHouseYear','wealth-downsizeHouseAmount','wealth-downsizeCOLYear','wealth-downsizeCOLAmount'];
        const keys = ['preTaxReturn','taxRate','costOfLiving','inflation','homeAppreciation','downsizeHouseYear','downsizeHouseAmount','downsizeCOLYear','downsizeCOLAmount'];
        keys.forEach((k, i) => { const el = document.getElementById(ids[i]); if (el) el.value = merged[k] ?? wealthProjectionDefaults[k]; });
      },

      reset() {
        this.setInputValues(wealthProjectionDefaults);
        this.saveToStorage();
        this.updateNetReturnDisplay();
        this.update();
      },

      getInputs() {
        const preTax = parseFloat(document.getElementById('wealth-preTaxReturn')?.value) || 0;
        const taxRate = parseFloat(document.getElementById('wealth-taxRate')?.value) || 0;
        const costOfLiving = parseFloat(document.getElementById('wealth-costOfLiving')?.value) || 0;
        const inflation = parseFloat(document.getElementById('wealth-inflation')?.value) || 0;
        const homeAppreciation = parseFloat(document.getElementById('wealth-homeAppreciation')?.value) || 0;
        const downsizeHouseYear = parseInt(document.getElementById('wealth-downsizeHouseYear')?.value, 10) || 0;
        const downsizeHouseAmount = parseFloat(document.getElementById('wealth-downsizeHouseAmount')?.value) || 0;
        const downsizeCOLYear = parseInt(document.getElementById('wealth-downsizeCOLYear')?.value, 10) || 0;
        const downsizeCOLAmount = parseFloat(document.getElementById('wealth-downsizeCOLAmount')?.value) || 0;
        const netReturnPct = preTax * (1 - taxRate / 100);
        return { preTax, taxRate, costOfLiving, inflation, homeAppreciation, netReturnPct, downsizeHouseYear, downsizeHouseAmount, downsizeCOLYear, downsizeCOLAmount };
      },

      updateNetReturnDisplay() {
        const { netReturnPct } = this.getInputs();
        document.getElementById('wealth-netReturn').textContent = netReturnPct.toFixed(2);
      },

      computeProjection(startingWealth, netReturnDec, costOfLiving, inflationDec, downsizeHouseYear, downsizeHouseAmount, downsizeCOLYear, downsizeCOLAmount) {
        const values = [startingWealth];
        let effectiveCOL = costOfLiving;
        for (let t = 1; t < this.numYears; t++) {
          const year = this.startYear + t;
          if (year === downsizeCOLYear) effectiveCOL = Math.max(0, effectiveCOL + downsizeCOLAmount);
          let growth = values[t - 1] * (1 + netReturnDec);
          if (year === downsizeHouseYear) growth += downsizeHouseAmount;
          values.push(Math.max(0, growth - effectiveCOL));
          effectiveCOL = effectiveCOL * (1 + inflationDec);
        }
        return values;
      },

      computeRealEstate(startingRealEstate, homeApprecDec, downsizeHouseYear, downsizeHouseAmount) {
        const values = [startingRealEstate];
        let re = startingRealEstate;
        for (let t = 1; t < this.numYears; t++) {
          const year = this.startYear + t;
          re = re * (1 + homeApprecDec);
          if (year === downsizeHouseYear) re = Math.max(0, re - downsizeHouseAmount);
          values.push(re);
        }
        return values;
      },

      computeBreakdown(startingWealth, netReturnDec, costOfLiving, inflationDec, downsizeHouseYear, downsizeHouseAmount, downsizeCOLYear, downsizeCOLAmount) {
        const rows = [{ year: this.startYear, netInvestment: startingWealth, postTaxEarnings: 0, costOfLiving: 0 }];
        let wealth = startingWealth;
        let effectiveCOL = costOfLiving;
        for (let t = 1; t < this.numYears; t++) {
          const year = this.startYear + t;
          if (year === downsizeCOLYear) effectiveCOL = Math.max(0, effectiveCOL + downsizeCOLAmount);
          const postTaxEarnings = wealth * netReturnDec;
          let nextWealth = wealth + postTaxEarnings - effectiveCOL;
          if (year === downsizeHouseYear) nextWealth += downsizeHouseAmount;
          rows.push({ year, netInvestment: Math.max(0, nextWealth), postTaxEarnings, costOfLiving: effectiveCOL });
          wealth = nextWealth;
          effectiveCOL = effectiveCOL * (1 + inflationDec);
        }
        return rows;
      },

      renderBreakdown() {
        const el = document.getElementById('wealth-breakdown');
        if (!el || this.startingWealth == null) return;
        const { netReturnPct, costOfLiving, inflation, downsizeHouseYear, downsizeHouseAmount, downsizeCOLYear, downsizeCOLAmount } = this.getInputs();
        const rows = this.computeBreakdown(this.startingWealth, netReturnPct / 100, costOfLiving, inflation / 100, downsizeHouseYear, downsizeHouseAmount, downsizeCOLYear, downsizeCOLAmount);
        const fmt = n => '$' + Math.round(n).toLocaleString();
        const pct = n => (n * 100).toFixed(2) + '%';
        const ret = (r, i) => i === 0 ? '—' : r.postTaxEarnings && rows[i - 1].netInvestment ? pct(r.postTaxEarnings / rows[i - 1].netInvestment) : '—';
        const infl = (r, i) => i === 0 || !rows[i - 1].costOfLiving ? '—' : pct((r.costOfLiving / rows[i - 1].costOfLiving) - 1);
        el.innerHTML = '<table class="breakdown-table"><thead><tr><th>Year</th><th>Net Investment</th><th>Post-Tax Earnings</th><th>Return</th><th>Cost of Living</th><th>Inflation</th></tr></thead><tbody>' +
          rows.map((r, i) => `<tr><td>${r.year}</td><td>${fmt(r.netInvestment)}</td><td>${fmt(r.postTaxEarnings)}</td><td>${ret(r, i)}</td><td>${fmt(r.costOfLiving)}</td><td>${infl(r, i)}</td></tr>`).join('') + '</tbody></table>';
      },

      update() {
        const { netReturnPct, costOfLiving, inflation, homeAppreciation, downsizeHouseYear, downsizeHouseAmount, downsizeCOLYear, downsizeCOLAmount } = this.getInputs();
        const netReturnDec = netReturnPct / 100;
        const inflationDec = inflation / 100;
        const homeApprecDec = homeAppreciation / 100;
        const startingWealth = this.startingWealth;
        const startingRealEstate = this.startingRealEstate;
        if (startingWealth == null || !this.instance) return;
        const netInv = this.computeProjection(startingWealth, netReturnDec, costOfLiving, inflationDec, downsizeHouseYear, downsizeHouseAmount, downsizeCOLYear, downsizeCOLAmount);
        const realEstate = this.computeRealEstate(startingRealEstate, homeApprecDec, downsizeHouseYear, downsizeHouseAmount);
        const netWorth = netInv.map((v, i) => v + realEstate[i]);
        this.instance.data.datasets[0].data = netInv;
        this.instance.data.datasets[1].data = realEstate;
        this.instance.data.datasets[2].data = netWorth;
        this.instance.update();
        this.renderBreakdown();
      },

      show() { setChartVisible(this.id, true); },
      hide() { setChartVisible(this.id, false); },

      async init() {
        const { netInvestments, realEstate: reVal } = balanceChart.getLatestForProjection();
        this.startingWealth = netInvestments;
        this.startingRealEstate = reVal;

        const labels = [];
        for (let y = this.startYear; y < this.startYear + this.numYears; y++) labels.push(y % 100);

        const { netReturnPct, costOfLiving, inflation, homeAppreciation, downsizeHouseYear, downsizeHouseAmount, downsizeCOLYear, downsizeCOLAmount } = this.getInputs();
        const netReturnDec = netReturnPct / 100;
        const inflationDec = inflation / 100;
        const homeApprecDec = homeAppreciation / 100;
        const netInv = this.computeProjection(this.startingWealth, netReturnDec, costOfLiving, inflationDec, downsizeHouseYear, downsizeHouseAmount, downsizeCOLYear, downsizeCOLAmount);
        const realEstate = this.computeRealEstate(this.startingRealEstate, homeApprecDec, downsizeHouseYear, downsizeHouseAmount);
        const netWorth = netInv.map((v, i) => v + realEstate[i]);

        const ctx = document.getElementById('wealthProjection-canvas').getContext('2d');
        this.instance = new Chart(ctx, {
          type: 'line',
          data: {
            labels,
            datasets: [
              { data: netInv, order: 3, borderColor: '#0ea5e9', backgroundColor: 'rgba(14, 165, 233, 0.2)', fill: true, tension: 0.3, pointRadius: 0, pointHoverRadius: 4, borderWidth: 4 },
              { data: realEstate, order: 2, borderColor: '#ef4444', fill: false, tension: 0.3, pointRadius: 0, pointHoverRadius: 4, borderWidth: 4 },
              { data: netWorth, order: 1, borderColor: '#22c55e', fill: false, tension: 0.3, pointRadius: 0, pointHoverRadius: 4, borderWidth: 4 }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: { padding: 6 },
            plugins: { legend: { display: false }, tooltip: { animation: { duration: 0 }, callbacks: { label: (ctx) => '$' + ctx.raw.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 }) } } },
            scales: {
              x: { title: { display: false }, grid: { display: false }, ticks: { color: '#555', font: { size: 11 }, maxRotation: 0 } },
              y: {
                min: 0, max: 100000000,
                title: { display: true, text: 'Projected wealth ($)', color: '#555', font: { size: 11 } },
                grid: { color: 'rgba(0,0,0,0.06)' },
                ticks: { color: '#555', font: { size: 11 }, stepSize: 10000000, callback: value => '$' + Math.round(value / 1000000) + 'M' }
              }
            }
          }
        });

        const inputs = await loadFinancialSnapshotInputs();
        const hasWealth = inputs && inputs.wealth && Object.keys(inputs.wealth).length > 0;
        if (hasWealth) this.setInputValues({ ...wealthProjectionDefaults, ...inputs.wealth });
        else {
          const stored = this.loadStored();
          if (stored) this.setInputValues(stored);
          else this.setInputValues(wealthProjectionDefaults);
        }
        this.update();

        const wealthApply = () => { this.updateNetReturnDisplay(); this.update(); this.saveToStorage(); };
        const wealthApplyDebounced = debounce(wealthApply, 5000);
        ['wealth-preTaxReturn', 'wealth-taxRate', 'wealth-costOfLiving', 'wealth-inflation', 'wealth-homeAppreciation', 'wealth-downsizeHouseYear', 'wealth-downsizeHouseAmount', 'wealth-downsizeCOLYear', 'wealth-downsizeCOLAmount'].forEach(id => {
          const el = document.getElementById(id);
          if (el) {
            el.addEventListener('input', () => wealthApplyDebounced());
            el.addEventListener('change', wealthApply);
            el.addEventListener('keydown', (e) => { if (e.key === 'Enter') el.blur(); });
          }
        });
        document.getElementById('wealth-reset').addEventListener('click', () => this.reset());
        this.updateNetReturnDisplay();
        this.renderBreakdown();
      }
    };

    const monteCarloDefaults = { simulations: '10000', returnVolatility: '17', homeApprecVolatility: '5', inflationVolatility: '1.5', budgetVolatility: '20', inflationReturnCorr: '-0.3' };
    const MC_STORAGE_KEY = 'financial-snapshot-montecarlo-inputs';

    // Monte Carlo chart
    const monteCarloChart = {
      id: 'wealth-montecarlo',
      instance: null,
      startYear: 2026,
      numYears: 41,
      startingWealth: null,
      startingRealEstate: null,

      loadStored() {
        try {
          const stored = localStorage.getItem(MC_STORAGE_KEY);
          return stored ? JSON.parse(stored) : null;
        } catch { return null; }
      },

      saveToStorage() {
        const vals = { simulations: document.getElementById('mc-simulations')?.value ?? '10000', returnVolatility: document.getElementById('mc-returnVolatility')?.value ?? '17', homeApprecVolatility: document.getElementById('mc-homeApprecVolatility')?.value ?? '5', inflationVolatility: document.getElementById('mc-inflationVolatility')?.value ?? '1.5', budgetVolatility: document.getElementById('mc-budgetVolatility')?.value ?? '20', inflationReturnCorr: document.getElementById('mc-inflationReturnCorr')?.value ?? '-0.3' };
        try { localStorage.setItem(MC_STORAGE_KEY, JSON.stringify(vals)); } catch (_) {}
      },

      setInputValues(vals) {
        const merged = { ...monteCarloDefaults, ...vals };
        const el = id => document.getElementById(id);
        if (el('mc-simulations')) el('mc-simulations').value = merged.simulations ?? monteCarloDefaults.simulations;
        if (el('mc-returnVolatility')) el('mc-returnVolatility').value = merged.returnVolatility ?? monteCarloDefaults.returnVolatility;
        if (el('mc-homeApprecVolatility')) el('mc-homeApprecVolatility').value = merged.homeApprecVolatility ?? monteCarloDefaults.homeApprecVolatility;
        if (el('mc-inflationVolatility')) el('mc-inflationVolatility').value = merged.inflationVolatility ?? monteCarloDefaults.inflationVolatility;
        if (el('mc-budgetVolatility')) el('mc-budgetVolatility').value = merged.budgetVolatility ?? monteCarloDefaults.budgetVolatility;
        if (el('mc-inflationReturnCorr')) el('mc-inflationReturnCorr').value = merged.inflationReturnCorr ?? monteCarloDefaults.inflationReturnCorr;
      },

      reset() {
        this.setInputValues(monteCarloDefaults);
        this.saveToStorage();
        this.update();
      },

      getInputs() {
        const wp = wealthProjectionChart.getInputs();
        const sims = parseInt(document.getElementById('mc-simulations')?.value, 10) || 10000;
        const vol = parseFloat(document.getElementById('mc-returnVolatility')?.value) || 17;
        const homeVol = parseFloat(document.getElementById('mc-homeApprecVolatility')?.value) || 5;
        const inflationVol = parseFloat(document.getElementById('mc-inflationVolatility')?.value) || 1.5;
        const budgetVol = parseFloat(document.getElementById('mc-budgetVolatility')?.value) || 20;
        const corr = parseFloat(document.getElementById('mc-inflationReturnCorr')?.value);
        const inflationReturnCorr = !isNaN(corr) ? Math.max(-1, Math.min(1, corr)) : -0.3;
        return { ...wp, simulations: Math.min(5000, Math.max(100, sims)), returnVolatility: vol, homeApprecVolatility: homeVol, inflationVolatility: inflationVol, budgetVolatility: budgetVol, inflationReturnCorr };
      },

      computeRealEstatePath(startingRealEstate, downsizeHouseYear, downsizeHouseAmount, getAppreciation) {
        const values = [startingRealEstate];
        let re = startingRealEstate;
        for (let t = 1; t < this.numYears; t++) {
          const year = this.startYear + t;
          re = re * (1 + getAppreciation(t));
          if (year === downsizeHouseYear) re = Math.max(0, re - downsizeHouseAmount);
          values.push(re);
        }
        return values;
      },

      computePath(startingWealth, costOfLiving, downsizeHouseYear, downsizeHouseAmount, downsizeCOLYear, downsizeCOLAmount, getReturnAndInflation, getBudgetMultiplier) {
        const values = [startingWealth];
        const colPath = [0];
        let effectiveCOL = costOfLiving;
        for (let t = 1; t < this.numYears; t++) {
          const year = this.startYear + t;
          if (year === downsizeCOLYear) effectiveCOL = Math.max(0, effectiveCOL + downsizeCOLAmount);
          const actualCOL = getBudgetMultiplier ? effectiveCOL * getBudgetMultiplier(t) : effectiveCOL;
          colPath.push(actualCOL);
          const { return: r, inflation: infl } = getReturnAndInflation(t);
          let growth = values[t - 1] * (1 + r);
          if (year === downsizeHouseYear) growth += downsizeHouseAmount;
          values.push(Math.max(0, growth - actualCOL));
          effectiveCOL = effectiveCOL * (1 + Math.max(0.01, infl));
        }
        return { values, colPath };
      },

      runSimulations() {
        const { netReturnPct, costOfLiving, inflation, homeAppreciation, downsizeHouseYear, downsizeHouseAmount, downsizeCOLYear, downsizeCOLAmount, simulations, returnVolatility, homeApprecVolatility, inflationVolatility, budgetVolatility, inflationReturnCorr } = this.getInputs();
        const netReturnDec = netReturnPct / 100;
        const volDec = returnVolatility / 100;
        const homeApprecDec = homeAppreciation / 100;
        const homeVolDec = homeApprecVolatility / 100;
        const inflationDec = inflation / 100;
        const inflationVolDec = inflationVolatility / 100;
        const budgetVolDec = (budgetVolatility || 0) / 100;
        const rho = Math.max(-0.99, Math.min(0.99, inflationReturnCorr));
        const rhoAdj = Math.sqrt(1 - rho * rho);

        const netInvPaths = [];
        const colPaths = [];
        const realEstatePaths = [];
        const netWorthPaths = [];

        for (let i = 0; i < simulations; i++) {
          const getReturnAndInflation = () => {
            const z1 = normalRandom(0, 1);
            const z2 = normalRandom(0, 1);
            const infl = inflationDec + inflationVolDec * z1;
            const r = netReturnDec + volDec * (rho * z1 + rhoAdj * z2);
            return { return: Math.max(-0.5, r), inflation: Math.max(0.01, infl) };
          };
          const inflCache = [];
          const retCache = [];
          const budgetMultipliers = [];
          for (let t = 1; t < this.numYears; t++) {
            const draw = getReturnAndInflation();
            inflCache.push(draw.inflation);
            retCache.push(draw.return);
            budgetMultipliers.push(1 + Math.random() * budgetVolDec);
          }
          const getBudgetMultiplier = budgetVolDec > 0 ? (t) => budgetMultipliers[t - 1] : null;
          const { values: netInv, colPath } = this.computePath(
            this.startingWealth, costOfLiving, downsizeHouseYear, downsizeHouseAmount, downsizeCOLYear, downsizeCOLAmount,
            (t) => ({ return: retCache[t - 1], inflation: inflCache[t - 1] }),
            getBudgetMultiplier
          );
          colPaths.push(colPath);
          const realEstate = this.computeRealEstatePath(
            this.startingRealEstate, downsizeHouseYear, downsizeHouseAmount,
            () => Math.max(-0.3, normalRandom(homeApprecDec, homeVolDec))
          );
          netInvPaths.push(netInv);
          realEstatePaths.push(realEstate);
          netWorthPaths.push(netInv.map((v, j) => v + realEstate[j]));
        }

        function calcPercentiles(paths) {
          const p10 = [], p25 = [], p50 = [], p75 = [], p90 = [];
          for (let t = 0; t < monteCarloChart.numYears; t++) {
            const vals = paths.map(p => p[t]);
            p10.push(percentile(vals, 10));
            p25.push(percentile(vals, 25));
            p50.push(percentile(vals, 50));
            p75.push(percentile(vals, 75));
            p90.push(percentile(vals, 90));
          }
          return { p10, p25, p50, p75, p90 };
        }

        function pickSamples(paths, n) {
          const out = [];
          for (let i = 0; i < n; i++) out.push(paths[Math.floor(Math.random() * paths.length)]);
          return out;
        }

        const medianCOL = [];
        for (let t = 0; t < this.numYears; t++) {
          const vals = colPaths.map(p => p[t]);
          medianCOL.push(percentile(vals, 50));
        }

        return {
          netInv: { ...calcPercentiles(netInvPaths), samples: pickSamples(netInvPaths, 5) },
          realEstate: { ...calcPercentiles(realEstatePaths), samples: pickSamples(realEstatePaths, 5) },
          netWorth: { ...calcPercentiles(netWorthPaths), samples: pickSamples(netWorthPaths, 5) },
          medianCOL
        };
      },

      computeBreakdownFromMedian(medianNetInv, medianCOL) {
        const rows = [{ year: this.startYear, netInvestment: medianNetInv[0], postTaxEarnings: 0, costOfLiving: 0 }];
        for (let t = 1; t < this.numYears; t++) {
          const year = this.startYear + t;
          const effectiveCOL = medianCOL[t];
          const prevWealth = medianNetInv[t - 1];
          const postTaxEarnings = prevWealth <= 0 ? 0 : Math.max(0, medianNetInv[t] - prevWealth + effectiveCOL);
          rows.push({ year, netInvestment: medianNetInv[t], postTaxEarnings, costOfLiving: effectiveCOL });
        }
        return rows;
      },

      renderBreakdown(runResult) {
        const el = document.getElementById('mc-breakdown');
        if (!el || this.startingWealth == null) return;
        const r = runResult || this.runSimulations();
        const rows = this.computeBreakdownFromMedian(r.netInv.p50, r.medianCOL);
        const fmt = n => '$' + Math.round(n).toLocaleString();
        const pct = n => (n * 100).toFixed(2) + '%';
        const ret = (rr, i) => i === 0 ? '—' : rr.postTaxEarnings && rows[i - 1].netInvestment ? pct(rr.postTaxEarnings / rows[i - 1].netInvestment) : '—';
        const infl = (rr, i) => i === 0 || !rows[i - 1].costOfLiving ? '—' : pct((rr.costOfLiving / rows[i - 1].costOfLiving) - 1);
        el.innerHTML = '<table class="breakdown-table"><thead><tr><th>Year</th><th>Net Investment</th><th>Post-Tax Earnings</th><th>Return</th><th>Cost of Living</th><th>Inflation</th></tr></thead><tbody>' +
          rows.map((rr, i) => `<tr><td>${rr.year}</td><td>${fmt(rr.netInvestment)}</td><td>${fmt(rr.postTaxEarnings)}</td><td>${ret(rr, i)}</td><td>${fmt(rr.costOfLiving)}</td><td>${infl(rr, i)}</td></tr>`).join('') + '</tbody></table>';
      },

      update() {
        if (this.startingWealth == null || !this.instance) return;
        const r = this.runSimulations();
        const d = this.instance.data.datasets;

        [r.realEstate.p10, r.realEstate.p25, r.realEstate.p50, r.realEstate.p75, r.realEstate.p90, ...r.realEstate.samples].forEach((data, i) => d[i].data = data);
        [r.netInv.p10, r.netInv.p25, r.netInv.p50, r.netInv.p75, r.netInv.p90, ...r.netInv.samples].forEach((data, i) => d[10 + i].data = data);
        [r.netWorth.p10, r.netWorth.p25, r.netWorth.p50, r.netWorth.p75, r.netWorth.p90, ...r.netWorth.samples].forEach((data, i) => d[20 + i].data = data);
        this.instance.update();
        this.renderBreakdown(r);
      },

      show() { setChartVisible(this.id, true); },
      hide() { setChartVisible(this.id, false); },

      async init() {
        const { netInvestments, realEstate: reVal } = balanceChart.getLatestForProjection();
        this.startingWealth = netInvestments;
        this.startingRealEstate = reVal;

        const inputs = await loadFinancialSnapshotInputs();
        const hasMc = inputs && inputs.monteCarlo && Object.keys(inputs.monteCarlo).length > 0;
        if (hasMc) this.setInputValues({ ...monteCarloDefaults, ...inputs.monteCarlo });
        else {
          const stored = this.loadStored();
          if (stored) this.setInputValues(stored);
          else this.setInputValues(monteCarloDefaults);
        }

        const labels = [];
        for (let y = this.startYear; y < this.startYear + this.numYears; y++) labels.push(y % 100);

        const r = this.runSimulations();
        const blue = '#0ea5e9', red = '#ef4444', green = '#22c55e';

        const ctx = document.getElementById('wealthMonteCarlo-canvas').getContext('2d');
        this.instance = new Chart(ctx, {
          type: 'line',
          data: {
            labels,
            datasets: [
              ...['p10','p25','p50','p75','p90'].map((k, i) => ({ data: r.realEstate[k], order: 30, borderColor: red, fill: false, tension: 0.3, pointRadius: 0, pointHoverRadius: 2, borderWidth: i === 2 ? 5 : (i === 1 || i === 3) ? 2 : 1 })),
              ...r.realEstate.samples.map((d, i) => ({ data: d, order: 29, borderColor: 'rgba(239,68,68,0.2)', fill: false, tension: 0.3, pointRadius: 0, pointHoverRadius: 2, borderWidth: 1 })),
              ...['p10','p25','p50','p75','p90'].map((k, i) => ({ data: r.netInv[k], order: 20, borderColor: blue, fill: false, tension: 0.3, pointRadius: 0, pointHoverRadius: 2, borderWidth: i === 2 ? 5 : (i === 1 || i === 3) ? 2 : 1 })),
              ...r.netInv.samples.map((d, i) => ({ data: d, order: 19, borderColor: 'rgba(14,165,233,0.2)', fill: false, tension: 0.3, pointRadius: 0, pointHoverRadius: 2, borderWidth: 1 })),
              ...['p10','p25','p50','p75','p90'].map((k, i) => ({ data: r.netWorth[k], order: 10, borderColor: green, fill: false, tension: 0.3, pointRadius: 0, pointHoverRadius: 2, borderWidth: i === 2 ? 5 : (i === 1 || i === 3) ? 2 : 1 })),
              ...r.netWorth.samples.map((d, i) => ({ data: d, order: 9, borderColor: 'rgba(34,197,94,0.2)', fill: false, tension: 0.3, pointRadius: 0, pointHoverRadius: 2, borderWidth: 1 }))
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            layout: { padding: 6 },
            plugins: { legend: { display: false }, tooltip: { animation: { duration: 0 }, callbacks: { label: (ctx) => '$' + ctx.raw.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 }) } } },
            scales: {
              x: { title: { display: false }, grid: { display: false }, ticks: { color: '#555', font: { size: 11 }, maxRotation: 0 } },
              y: {
                min: 0, max: 120000000,
                title: { display: true, text: 'Net worth ($)', color: '#555', font: { size: 11 } },
                grid: { color: 'rgba(0,0,0,0.06)' },
                ticks: { color: '#555', font: { size: 11 }, stepSize: 10000000, callback: value => '$' + Math.round(value / 1000000) + 'M' }
              }
            }
          }
        });

        this.renderBreakdown(r);

        const mcApply = () => { this.update(); this.saveToStorage(); };
        const mcApplyDebounced = debounce(mcApply, 5000);
        ['mc-simulations', 'mc-returnVolatility', 'mc-homeApprecVolatility', 'mc-inflationVolatility', 'mc-budgetVolatility', 'mc-inflationReturnCorr'].forEach(id => {
          const el = document.getElementById(id);
          if (el) {
            el.addEventListener('input', () => mcApplyDebounced());
            el.addEventListener('change', mcApply);
            el.addEventListener('keydown', (e) => { if (e.key === 'Enter') el.blur(); });
          }
        });
        document.getElementById('mc-rerun')?.addEventListener('click', () => this.update());
        document.getElementById('mc-reset')?.addEventListener('click', () => this.reset());

        const wealthToMcApply = () => this.update();
        const wealthToMcApplyDebounced = debounce(wealthToMcApply, 5000);
        ['wealth-preTaxReturn', 'wealth-taxRate', 'wealth-costOfLiving', 'wealth-inflation', 'wealth-homeAppreciation', 'wealth-downsizeHouseYear', 'wealth-downsizeHouseAmount', 'wealth-downsizeCOLYear', 'wealth-downsizeCOLAmount'].forEach(id => {
          const el = document.getElementById(id);
          if (el) {
            el.addEventListener('input', () => wealthToMcApplyDebounced());
            el.addEventListener('change', wealthToMcApply);
            el.addEventListener('keydown', (e) => { if (e.key === 'Enter') el.blur(); });
          }
        });
      }
    };

    const budgetChart = {
      loaded: false,
      instances: [],
      chartInstances: {},
      transactions: [],
      byCategory: {},
      committedItems: [],
      storedBudgets: null,
      loadStoredBudgets() {
        try {
          const s = localStorage.getItem(BUDGET_STORAGE_KEY);
          this.storedBudgets = s ? JSON.parse(s) : {};
          return this.storedBudgets;
        } catch (_) { this.storedBudgets = {}; return {}; }
      },
      saveBudgets() {
        try { localStorage.setItem(BUDGET_STORAGE_KEY, JSON.stringify(this.storedBudgets || {})); } catch (_) {}
      },
      isIncomeCategory(category) {
        return BUDGET_CATEGORIES.some(b => b.grouping === 'Income' && b.category === category);
      },
      formatBudgetTick(v, isIncome) {
        if (v === 0) return '$0';
        const sign = isIncome ? '' : '-';
        const abs = Math.abs(v);
        if (abs >= 1000000) return sign + '$' + (abs / 1000000).toFixed(1) + 'm';
        if (abs >= 1000) return sign + '$' + Math.round(abs / 1000) + 'k';
        return sign + '$' + Math.round(abs);
      },
      getBudget(category) {
        if (!this.storedBudgets) this.loadStoredBudgets();
        const v = this.storedBudgets[category];
        if (v == null || isNaN(parseFloat(v))) return this.isIncomeCategory(category) ? BUDGET_DEFAULT : -BUDGET_DEFAULT;
        const num = parseFloat(v);
        if (this.isIncomeCategory(category)) return num;
        return num > 0 ? -num : num;
      },
      setBudget(category, value) {
        if (!this.storedBudgets) this.loadStoredBudgets();
        const n = parseFloat(value);
        if (!isNaN(n)) {
          this.storedBudgets[category] = n;
          this.saveBudgets();
        }
      },
      updateTotals() {
        const el = document.getElementById('budget-totals-summary');
        if (!el) return;
        let totalBudgetExpense = 0, totalSpending = 0, totalIncome = 0, totalBudgetIncome = 0, totalCommittedExpense = 0, totalCommittedIncome = 0;
        for (const { grouping, category } of BUDGET_CATEGORIES) {
          const isIncome = this.isIncomeCategory(category);
          const txs = this.getTxsForCategory(category);
          const b = this.getBudget(category);
          const comm = this.getCommitted(category);
          if (isIncome) {
            totalIncome += this.getIncomeForTotal(txs);
            totalBudgetIncome += b;
            totalCommittedIncome += comm;
          } else {
            totalSpending += this.getSpendingForTotal(txs);
            totalBudgetExpense += b;
            totalCommittedExpense += comm;
          }
        }
        const spend = totalSpending;
        const committed = totalCommittedExpense;
        const pctBudget = totalBudgetExpense < 0 ? (Math.abs(spend + committed) / Math.abs(totalBudgetExpense)) * 100 : 0;
        const now = new Date();
        const startOfYear = new Date(now.getFullYear(), 0, 1);
        const endOfYear = new Date(now.getFullYear(), 11, 31);
        const daysInYear = Math.round((endOfYear - startOfYear) / 86400000) + 1;
        const dayOfYear = Math.round((now - startOfYear) / 86400000) + 1;
        const timeProgress = Math.min(1, Math.max(0, dayOfYear / daysInYear)) || 0.001;
        const todayLineValue = Math.abs(totalBudgetExpense) * timeProgress;
        const totalWithCommitted = spend + committed;
        const maxVal = Math.max(Math.abs(totalBudgetExpense), Math.abs(totalWithCommitted), 1);
        const pct = Math.abs(totalBudgetExpense) > 0 ? Math.abs(totalWithCommitted) / Math.abs(totalBudgetExpense) : 0;
        const barColor = pct <= 0.8 ? '#22c55e' : (pct <= 1 ? '#eab308' : '#ef4444');
        const totalsCommittedCurOrPast = BUDGET_CATEGORIES.reduce((s, { category }) => {
          if (this.isIncomeCategory(category)) return s;
          return s + this.getCommittedCurrentOrPast(category);
        }, 0);
        const totalsCommittedFuture = BUDGET_CATEGORIES.reduce((s, { category }) => {
          if (this.isIncomeCategory(category)) return s;
          return s + this.getCommittedFuture(category);
        }, 0);
        const [tr, tg, tb] = barColor === '#22c55e' ? [34, 197, 94] : (barColor === '#eab308' ? [234, 179, 8] : [239, 68, 68]);
        const totalsCommittedCurOrPastColor = 'rgba(' + tr + ',' + tg + ',' + tb + ',0.66)';
        const totalsCommittedFutureColor = 'rgba(' + tr + ',' + tg + ',' + tb + ',0.33)';
        const totalsBudgetLinesPlugin = {
          id: 'totalsBudgetLines',
          afterDatasetsDraw(chart) {
            const opts = chart.options.plugins?.totalsBudgetLines;
            const ctx = chart.ctx;
            const xScale = chart.scales.x;
            if (!xScale) return;
            const top = chart.chartArea.top;
            const bottom = chart.chartArea.bottom;
            const left = chart.chartArea.left;
            const right = chart.chartArea.right;
            if (opts?.todayValue != null) {
              const x = xScale.getPixelForValue(opts.todayValue);
              if (x >= left - 1 && x <= right + 1) {
                ctx.save();
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(x, top);
                ctx.lineTo(x, bottom);
                ctx.stroke();
                ctx.restore();
              }
            }
            const totalsOverflow = opts?.budgetValue != null && opts?.spending != null && opts.spending > opts.budgetValue;
            if (totalsOverflow) {
              const x = xScale.getPixelForValue(opts.budgetValue);
              if (x >= left - 1 && x <= right + 1) {
                ctx.save();
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(x, top);
                ctx.lineTo(x, bottom);
                ctx.stroke();
                ctx.restore();
              }
            }
          }
        };
        const totalsDatasets = [];
        totalsDatasets.push({ data: [Math.max(0, -spend)], backgroundColor: barColor, barThickness: 48, stack: 'totals0' });
        if (totalsCommittedCurOrPast < 0) totalsDatasets.push({ data: [Math.abs(totalsCommittedCurOrPast)], backgroundColor: totalsCommittedCurOrPastColor, barThickness: 48, stack: 'totals0' });
        if (totalsCommittedFuture < 0) totalsDatasets.push({ data: [Math.abs(totalsCommittedFuture)], backgroundColor: totalsCommittedFutureColor, barThickness: 48, stack: 'totals0' });
        const chartWrap = '<div class="budget-totals-chart-wrap"><canvas id="budget-totals-chart"></canvas></div>';
        const errorBanner = this.committedLoadError
          ? '<div class="budget-committed-error">error in budget_committed.csv' +
            (Array.isArray(this.committedLoadErrors) && this.committedLoadErrors.length > 0
              ? ': ' + this.committedLoadErrors.join('; ')
              : '') + '</div>'
          : '';
        const totalSpend = spend + committed;
        const totalIncomeSum = totalIncome + totalCommittedIncome;
        const netEarnings = totalSpend + totalIncomeSum;
        const fmtTotals = n => (n >= 0 ? '' : '-') + '$' + Math.round(Math.abs(n)).toLocaleString();
        const statsHtml = errorBanner + '<div class="budget-totals-row">' +
          '<div class="budget-totals-stats">' +
          '<div class="budget-totals-group">' +
          '<div class="budget-totals-group-header">Spending</div>' +
          '<div class="budget-totals-group-items">' +
          '<div class="budget-totals-group-item"><span class="budget-totals-label" style="color:rgb(255,0,0)">Spending to Date</span><span class="budget-totals-value" style="color:rgb(255,0,0)">' + fmtTotals(spend) + '</span></div>' +
          '<div class="budget-totals-group-item"><span class="budget-totals-label" style="color:rgb(128,0,0)">Committed Spend</span><span class="budget-totals-value" style="color:rgb(128,0,0)">' + fmtTotals(committed) + '</span></div>' +
          '<div class="budget-totals-group-item"><span class="budget-totals-label" style="color:rgb(255,128,128)">Total Spend</span><span class="budget-totals-value" style="color:rgb(255,128,128)">' + fmtTotals(totalSpend) + '</span></div>' +
          '</div>' +
          '</div>' +
          '<div class="budget-totals-group">' +
          '<div class="budget-totals-group-header">Income</div>' +
          '<div class="budget-totals-group-items">' +
          '<div class="budget-totals-group-item"><span class="budget-totals-label" style="color:rgb(0,255,0)">Income to Date</span><span class="budget-totals-value" style="color:rgb(0,255,0)">' + fmtTotals(totalIncome) + '</span></div>' +
          '<div class="budget-totals-group-item"><span class="budget-totals-label" style="color:rgb(0,128,0)">Anticipated Income</span><span class="budget-totals-value" style="color:rgb(0,128,0)">' + fmtTotals(totalCommittedIncome) + '</span></div>' +
          '<div class="budget-totals-group-item"><span class="budget-totals-label" style="color:rgb(128,255,128)">Total Income</span><span class="budget-totals-value" style="color:rgb(128,255,128)">' + fmtTotals(totalIncomeSum) + '</span></div>' +
          '</div>' +
          '</div>' +
          '<div class="budget-totals-group budget-totals-group-narrow">' +
          '<div class="budget-totals-group-header">Net Income</div>' +
          '<div class="budget-totals-group-items">' +
          '<div class="budget-totals-group-item"><span class="budget-totals-label" style="color:white">Net Income</span><span class="budget-totals-value" style="color:white" id="budget-net-earnings-value">' + fmtTotals(netEarnings) + '</span></div>' +
          '</div>' +
          '</div>' +
          '<div class="budget-totals-line2">' +
          '<div class="budget-total-item"><span class="budget-total-label" style="color:white">Total Budget (Expense)</span><span class="budget-total-value" style="color:white" id="budget-total-budget-value">' + fmtTotals(totalBudgetExpense) + '</span></div>' +
          '<div class="budget-total-item"><span class="budget-total-label" style="color:white">% Budget</span><span class="budget-total-value" style="color:white">' + pctBudget.toFixed(1) + '%</span></div>' +
          '<button type="button" id="budget-save-csv" class="budget-save-csv-btn">Save .csv</button>' +
          '</div>' +
          '</div></div>';
        el.innerHTML = statsHtml + chartWrap;
        if (this.totalsChart) { this.totalsChart.destroy(); this.totalsChart = null; }
        const canvas = document.getElementById('budget-totals-chart');
        if (canvas) {
          const ctx = canvas.getContext('2d');
          this.totalsChart = new Chart(ctx, {
            type: 'bar',
            plugins: [totalsBudgetLinesPlugin],
            data: { labels: ['Total'], datasets: totalsDatasets },
            options: {
              indexAxis: 'y',
              responsive: true,
              maintainAspectRatio: false,
              layout: { padding: { left: 4, right: 12, top: 4, bottom: 4 } },
              plugins: {
                legend: { display: false },
                totalsBudgetLines: { todayValue: todayLineValue, budgetValue: Math.abs(totalBudgetExpense), spending: Math.abs(totalWithCommitted), isIncome: false }
              },
              scales: {
                x: {
                  min: 0,
                  max: maxVal,
                  stacked: committed < 0,
                  border: { display: true, color: 'rgba(255,255,255,0.5)' },
                  grid: { display: true, drawOnChartArea: true, color: 'rgba(255,255,255,0.35)' },
                  ticks: { color: 'rgba(255,255,255,0.9)', maxTicksLimit: 6, callback: (v, i, vals) => { const s = this.formatBudgetTick(v, false); return (i > 0 && this.formatBudgetTick(vals[i - 1], false) === s) ? '' : s; }, maxRotation: 0, font: { size: 16, weight: '600' } }
                },
                y: { stacked: committed < 0, display: false }
              }
            }
          });
          this.instances = this.instances || [];
          this.instances.push(this.totalsChart);
        }
        document.getElementById('budget-save-csv')?.addEventListener('click', () => this.exportBudgetsCsv());
      },
      async loadBudgetsFromCsv() {
        const path = await findBudgetLimitsCsvPath();
        if (!path) return false;
        try {
          const r = await fetch(path, { cache: 'no-store' });
          const text = await r.text();
          const rows = parseCsvLines(text);
          if (!this.storedBudgets) this.storedBudgets = {};
          for (let i = 1; i < rows.length; i++) {
            const row = rows[i];
            if (row.length < 2) continue;
            const cat = (row[0] || '').trim();
            const val = parseFloat((row[1] || '').toString().replace(/,/g, ''));
            const canonical = resolveBudgetCategory(cat);
            if (canonical && !isNaN(val)) {
              const isInc = BUDGET_CATEGORIES.some(b => b.grouping === 'Income' && b.category === canonical);
              this.storedBudgets[canonical] = isInc ? val : (val > 0 ? -val : val);
            }
          }
          this.saveBudgets();
          return true;
        } catch (_) { return false; }
      },
      async loadBudgetsCommitted() {
        this.committedLoadError = false;
        this.committedLoadErrors = [];
        const path = await findBudgetCommittedCsvPath();
        if (!path) { this.committedItems = []; return; }
        try {
          const r = await fetch(path, { cache: 'no-store' });
          const text = await r.text();
          const rows = parseCsvLines(text);
          const items = [];
          for (let i = 1; i < rows.length; i++) {
            const row = rows[i];
            const rowNum = i + 1;
            if (row.length < 6) {
              if ((row[0] || '').trim().toLowerCase() === 'true') {
                this.committedLoadError = true;
                this.committedLoadErrors.push('Row ' + rowNum + ': too few columns (need 6: Active, Category, Merchant, Type, Amount, StartMonth)');
              }
              continue;
            }
            const active = (row[0] || '').trim().toLowerCase();
            if (active !== 'true') continue;
            const catRaw = (row[1] || '').trim();
            const canonical = BUDGET_CATEGORIES.find(b => b.category.toLowerCase() === catRaw.toLowerCase())?.category;
            if (!canonical) {
              this.committedLoadError = true;
              this.committedLoadErrors.push('Row ' + rowNum + ': unknown category "' + (catRaw || '(empty)') + '"');
              continue;
            }
            const merchant = (row[2] || '').trim();
            const type = (row[3] || '').trim().toLowerCase();
            const amount = parseFloat(row[4]);
            const startMonth = parseInt(row[5], 10);
            const endMonth = row.length >= 7 && (row[6] || '').trim() ? parseInt(row[6], 10) : startMonth;
            if (isNaN(amount) || amount === 0) {
              this.committedLoadError = true;
              this.committedLoadErrors.push('Row ' + rowNum + ' (' + (merchant || '?') + '): invalid amount "' + (row[4] || '') + '" (use negative for expenses, positive for income)');
              continue;
            }
            if (type === 'one-time') {
              if (startMonth >= 1 && startMonth <= 12) items.push({ category: canonical, merchant, type: 'one-time', amount, startMonth, endMonth: startMonth });
              else {
                this.committedLoadError = true;
                this.committedLoadErrors.push('Row ' + rowNum + ' (' + (merchant || '?') + '): one-time needs StartMonth 1-12, got ' + startMonth);
              }
            } else if (type === 'monthly') {
              const sm = Math.max(1, Math.min(12, isNaN(startMonth) ? 1 : startMonth));
              const em = Math.max(1, Math.min(12, isNaN(endMonth) ? sm : endMonth));
              for (let m = Math.min(sm, em); m <= Math.max(sm, em); m++) {
                items.push({ category: canonical, merchant, type: 'monthly', amount, startMonth: m, endMonth: m });
              }
            } else {
              this.committedLoadError = true;
              this.committedLoadErrors.push('Row ' + rowNum + ' (' + (merchant || '?') + '): Type must be "monthly" or "one-time", got "' + (type || '(empty)') + '"');
            }
          }
          this.committedItems = items;
        } catch (err) {
          this.committedItems = [];
          this.committedLoadError = true;
          this.committedLoadErrors = ['Failed to load file: ' + (err && err.message ? err.message : 'unknown error')];
        }
      },
      getCommitted(category) {
        if (!Array.isArray(this.committedItems)) return 0;
        return this.committedItems
          .filter(i => i.category === category)
          .reduce((s, i) => s + i.amount, 0);
      },
      getCommittedCurrentMonth(category) {
        if (!Array.isArray(this.committedItems)) return 0;
        const now = new Date();
        const currentMonth = now.getMonth() + 1;
        return this.committedItems
          .filter(i => i.category === category && i.startMonth === currentMonth)
          .reduce((s, i) => s + i.amount, 0);
      },
      getCommittedCurrentOrPast(category) {
        if (!Array.isArray(this.committedItems)) return 0;
        const now = new Date();
        const currentMonth = now.getMonth() + 1;
        return this.committedItems
          .filter(i => i.category === category && i.startMonth <= currentMonth)
          .reduce((s, i) => s + i.amount, 0);
      },
      getCommittedFuture(category) {
        if (!Array.isArray(this.committedItems)) return 0;
        const now = new Date();
        const currentMonth = now.getMonth() + 1;
        return this.committedItems
          .filter(i => i.category === category && i.startMonth > currentMonth)
          .reduce((s, i) => s + i.amount, 0);
      },
      getCommittedRows(category) {
        if (!Array.isArray(this.committedItems)) return [];
        const year = new Date().getFullYear();
        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        return this.committedItems
          .filter(i => i.category === category)
          .map(i => {
            const d = new Date(year, i.startMonth - 1, 1);
            return {
              date: monthNames[i.startMonth - 1] + ' 1, ' + year,
              dateObj: d,
              merchant: i.merchant,
              category: i.category,
              tag: '',
              amount: i.amount,
              committed: true
            };
          });
      },
      exportBudgetsCsv() {
        const lines = ['Category,Budget'];
        for (const { category } of BUDGET_CATEGORIES) {
          const b = this.getBudget(category);
          const esc = (s) => (/[",\r\n]/.test(s) ? '"' + s.replace(/"/g, '""') + '"' : s);
          lines.push(esc(category) + ',' + Math.round(b));
        }
        saveCsvFile('budget_limits.csv', lines.join('\r\n'));
      },
      async init() {
        if (this.loaded) return;
        const path = await findTransactionsCsvPath();
        const response = await fetch(path);
        const text = await response.text();
        const rows = parseCsvLines(text);
        const year = new Date().getFullYear();
        this.transactions = [];
        for (let i = 1; i < rows.length; i++) {
          const row = rows[i];
          if (row.length < 7) continue;
          const dateStr = row[0];
          const merchant = row[1] || '';
          const csvCat = row[2] || '';
          const amount = parseFloat(row[6]);
          const tag = (row[7] || '').trim() || undefined;
          if (!dateStr || isNaN(amount)) continue;
          const d = parseDateIso(dateStr);
          if (isNaN(d.getTime()) || d.getFullYear() !== year) continue;
          let category = resolveCategory(csvCat);
          if (category == null) continue;
          const isIgnoredTag = tag && IGNORED_TAGS.some(ig => ig === tag);
          if (isIgnoredTag) {
            category = 'Categorized but not Budgeted';
          }
          this.transactions.push({ date: dateStr, dateObj: d, merchant, category, tag, amount, hidden: !!isIgnoredTag });
        }
        this.byCategory = {};
        for (const t of this.transactions) {
          if (!this.byCategory[t.category]) this.byCategory[t.category] = [];
          this.byCategory[t.category].push(t);
        }
        const fromCsv = await this.loadBudgetsFromCsv();
        if (!fromCsv) this.loadStoredBudgets();
        try { await this.loadBudgetsCommitted(); } catch (_) { this.committedItems = []; }
        this.render();
        this.updateTotals();
        this.loaded = true;
      },
      getTxsForCategory(category) {
        const txs = this.byCategory[category] || [];
        return category === 'Categorized but not Budgeted' ? txs.filter(t => !t.hidden) : txs;
      },
      getSpending(txs) {
        return txs.reduce((sum, t) => sum + t.amount, 0);
      },
      getIncome(txs) {
        return txs.reduce((sum, t) => sum + t.amount, 0);
      },
      getSpendingForTotal(txs) {
        return txs.reduce((sum, t) => sum + t.amount, 0);
      },
      getIncomeForTotal(txs) {
        return txs.reduce((sum, t) => sum + t.amount, 0);
      },
      render() {
        const el = document.getElementById('budget-content');
        if (!el) return;
        this.chartInstances = {};
        const groupsWithSpend = new Set();
        const groupBudgets = {};
        const groupCategories = {};
        for (const { grouping, category } of BUDGET_CATEGORIES) {
          const txs = this.getTxsForCategory(category);
          const isIncome = this.isIncomeCategory(category);
          const spend = this.getSpending(txs);
          const income = this.getIncome(txs);
          const comm = this.getCommitted(category);
          if (isIncome) {
            if (income !== 0 || comm !== 0) groupsWithSpend.add(grouping);
          } else {
            if (spend !== 0 || comm !== 0) groupsWithSpend.add(grouping);
          }
          groupBudgets[grouping] = (groupBudgets[grouping] || 0) + this.getBudget(category);
          if (!groupCategories[grouping]) groupCategories[grouping] = [];
          groupCategories[grouping].push(category);
        }
        const sortedGroups = [...new Set(BUDGET_CATEGORIES.map(b => b.grouping))].sort((a, b) => {
          if (a === 'Income') return -1;
          if (b === 'Income') return 1;
          return Math.abs(groupBudgets[b] || 0) - Math.abs(groupBudgets[a] || 0);
        });
        let html = '';
        for (const grouping of sortedGroups) {
          const groupExpanded = groupsWithSpend.has(grouping);
          const groupTotal = groupBudgets[grouping] || 0;
          const groupId = 'group-' + grouping.replace(/[^a-zA-Z0-9]/g, '-');
          html += `<div class="budget-grouping" data-expanded="${groupExpanded}" data-grouping="${grouping.replace(/"/g, '&quot;')}">
            <h3 class="budget-grouping-title">
              <span class="budget-grouping-title-inner"><span class="budget-grouping-toggle">▾</span>${grouping}</span>
              <span class="budget-group-total" id="budget-group-total-${groupId}">$${groupTotal >= 0 ? '' : '-'}${Math.round(Math.abs(groupTotal)).toLocaleString()}</span>
            </h3>
            <div class="budget-grouping-categories">`;
          for (const category of groupCategories[grouping]) {
            const txs = this.getTxsForCategory(category);
            const isIncome = this.isIncomeCategory(category);
            const spending = this.getSpending(txs);
            const income = this.getIncome(txs);
            const committed = this.getCommitted(category);
            const budget = this.getBudget(category);
            const val = isIncome ? income : spending;
            const totalVal = val + committed;
            const hasActivity = (val !== 0 || committed !== 0);
            const fmtSigned = (n) => (n >= 0 ? '' : '-') + Math.round(Math.abs(n)).toLocaleString();
            const id = 'budget-chart-' + category.replace(/[^a-zA-Z0-9]/g, '-');
            const inputId = 'budget-input-' + category.replace(/[^a-zA-Z0-9]/g, '-');
            const labelId = 'budget-label-' + category.replace(/[^a-zA-Z0-9]/g, '-');
            const labelStr = isIncome
              ? `${category} — $${fmtSigned(val)}${committed !== 0 ? ' + $' + fmtSigned(committed) : ''} = $${fmtSigned(totalVal)} / $${fmtSigned(budget)}`
              : `${category} — $${fmtSigned(val)}${committed !== 0 ? ' + $' + fmtSigned(committed) : ''} = $${fmtSigned(totalVal)} / $${fmtSigned(budget)}`;
            html += `<div class="budget-category-card" data-expanded="${hasActivity ? 'true' : 'false'}" data-category="${category.replace(/"/g, '&quot;')}">
              <div class="budget-category-header">
                <span class="budget-category-header-inner">
                  <span class="budget-category-toggle">▾</span>
                  <span class="budget-category-label" id="${labelId}">${labelStr}</span>
                </span>
                <input type="text" class="budget-input" id="${inputId}" data-category="${category.replace(/"/g, '&quot;')}" data-grouping="${grouping.replace(/"/g, '&quot;')}" value="${budget >= 0 ? '' : '-'}${Math.round(Math.abs(budget)).toLocaleString()}" inputmode="numeric">
              </div>
              <div class="budget-category-body">
                <div class="budget-category-chart"><canvas id="${id}"></canvas></div>
                <details><summary>Data</summary><div class="breakdown-content" id="budget-data-${id}" style="max-height: 200px; overflow: auto;"></div></details>
              </div>
            </div>`;
          }
          html += '</div></div>';
        }
        el.innerHTML = html;
        const now = new Date();
        const startOfYear = new Date(now.getFullYear(), 0, 1);
        const endOfYear = new Date(now.getFullYear(), 11, 31);
        const daysInYear = Math.round((endOfYear - startOfYear) / 86400000) + 1;
        const dayOfYear = Math.round((now - startOfYear) / 86400000) + 1;
        const todayProgress = Math.min(1, Math.max(0, dayOfYear / daysInYear));
        const budgetLinesPlugin = {
          id: 'budgetLines',
          afterDatasetsDraw(chart) {
            const opts = chart.options.plugins?.budgetLines;
            const ctx = chart.ctx;
            const xScale = chart.scales.x;
            if (!xScale) return;
            const top = chart.chartArea.top;
            const bottom = chart.chartArea.bottom;
            const left = chart.chartArea.left;
            const right = chart.chartArea.right;
            if (opts?.todayValue != null) {
              const x = xScale.getPixelForValue(opts.todayValue);
              if (x >= left - 1 && x <= right + 1) {
                ctx.save();
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, top);
                ctx.lineTo(x, bottom);
                ctx.stroke();
                ctx.restore();
              }
            }
            const overflow = opts?.budgetValue != null && opts?.spending != null && opts.spending > opts.budgetValue;
            if (overflow) {
              const x = xScale.getPixelForValue(opts.budgetValue);
              if (x >= left - 1 && x <= right + 1) {
                ctx.save();
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x, top);
                ctx.lineTo(x, bottom);
                ctx.stroke();
                ctx.restore();
              }
            }
          }
        };
        for (const { grouping, category } of BUDGET_CATEGORIES) {
          const txs = this.getTxsForCategory(category);
          const isIncome = this.isIncomeCategory(category);
          const spending = this.getSpending(txs);
          const income = this.getIncome(txs);
          const committed = this.getCommitted(category);
          const committedCurOrPast = this.getCommittedCurrentOrPast(category);
          const committedFuture = this.getCommittedFuture(category);
          const budget = this.getBudget(category);
          const val = isIncome ? income : spending;
          const totalWithCommitted = val + committed;
          const maxVal = Math.max(Math.abs(budget), Math.abs(totalWithCommitted), 1);
          const scaleMin = 0;
          const scaleMax = maxVal;
          const barData1 = isIncome ? Math.max(0, val) : Math.max(0, -val);
          const todayLineValue = Math.abs(budget) * todayProgress;
          const budgetLineValue = Math.abs(budget);
          const pctForColor = Math.abs(budget) > 0 ? Math.abs(totalWithCommitted) / Math.abs(budget) : 0;
          const spendingForPlugin = Math.abs(totalWithCommitted);
          const barColor = pctForColor <= 0.8 ? '#22c55e' : (pctForColor <= 1 ? '#eab308' : '#ef4444');
          const [r, g, b] = barColor === '#22c55e' ? [34, 197, 94] : (barColor === '#eab308' ? [234, 179, 8] : [239, 68, 68]);
          const committedCurOrPastColor = 'rgba(' + r + ',' + g + ',' + b + ',0.66)';
          const committedFutureColor = 'rgba(' + r + ',' + g + ',' + b + ',0.33)';
          const id = 'budget-chart-' + category.replace(/[^a-zA-Z0-9]/g, '-');
          const inputId = 'budget-input-' + category.replace(/[^a-zA-Z0-9]/g, '-');
          const canvas = document.getElementById(id);
          if (canvas) {
            const ctx = canvas.getContext('2d');
            const datasets = [];
            const barData2 = Math.abs(committedCurOrPast);
            const barData3 = Math.abs(committedFuture);
            datasets.push({ data: [barData1], backgroundColor: barColor, stack: 'stack0' });
            if (committedCurOrPast !== 0) datasets.push({ data: [barData2], backgroundColor: committedCurOrPastColor, stack: 'stack0' });
            if (committedFuture !== 0) datasets.push({ data: [barData3], backgroundColor: committedFutureColor, stack: 'stack0' });
            const hasStacked = committed !== 0;
            const inst = new Chart(ctx, {
              type: 'bar',
              plugins: [budgetLinesPlugin],
              data: { labels: [category], datasets },
              options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: false,
                layout: { padding: { left: 2, right: 8, top: 2, bottom: 2 } },
                plugins: {
                  legend: { display: false },
                  budgetLines: { todayValue: todayLineValue, budgetValue: budgetLineValue, spending: spendingForPlugin, isIncome }
                },
                scales: {
                  x: {
                    min: scaleMin,
                    max: scaleMax,
                    stacked: hasStacked,
                    ticks: { maxTicksLimit: 6, callback: (v, i, vals) => { const s = this.formatBudgetTick(v, isIncome); return (i > 0 && this.formatBudgetTick(vals[i - 1], isIncome) === s) ? '' : s; }, maxRotation: 0, font: { size: 11 } }
                  },
                  y: { stacked: hasStacked, display: false }
                }
              }
            });
            this.instances.push(inst);
            this.chartInstances[category] = inst;
          }
          const dataEl = document.getElementById('budget-data-' + id);
          if (dataEl) {
            const fmt = d => d ? monthNames[d.getMonth()] + ' ' + d.getDate() + ', ' + d.getFullYear() : '';
            const amountFmt = n => n === 0 ? '$0' : (n < 0 ? '-$' : '$') + Math.round(Math.abs(n)).toLocaleString();
            const committedRows = this.getCommittedRows(category);
            const allRows = [...txs, ...committedRows].sort((a, b) => a.dateObj - b.dateObj);
            const rowHtml = r => {
              const cls = r.committed ? ' class="committed-row"' : '';
              return `<tr${cls}><td>${fmt(r.dateObj)}</td><td>${(r.merchant || '').replace(/</g, '&lt;')}</td><td>${(r.category || '').replace(/</g, '&lt;')}</td><td>${(r.tag || '').replace(/</g, '&lt;')}</td><td>${amountFmt(r.amount)}</td></tr>`;
            };
            let dataHtml = '<table class="breakdown-table"><thead><tr><th>Date</th><th>Merchant</th><th>Category</th><th>Tag</th><th>Amount</th></tr></thead><tbody>' +
              allRows.map(rowHtml).join('') + '</tbody></table>';
            if (category === 'Categorized but not Budgeted' && (IGNORED_CATEGORIES.length || IGNORED_TAGS.length)) {
              if (IGNORED_CATEGORIES.length) {
                dataHtml += '<p class="budget-ignored-note">Ignored Categories: ' + IGNORED_CATEGORIES.join(', ') + '</p>';
              }
              if (IGNORED_TAGS.length) {
                dataHtml += '<p class="budget-ignored-note">Ignored Tags: ' + IGNORED_TAGS.join(', ') + '</p>';
              }
            }
            dataEl.innerHTML = dataHtml;
          }
        }
        el.addEventListener('click', (e) => {
          const groupTitle = e.target.closest('.budget-grouping-title');
          if (groupTitle) {
            const group = groupTitle.closest('.budget-grouping');
            if (group) group.setAttribute('data-expanded', group.getAttribute('data-expanded') === 'true' ? 'false' : 'true');
            return;
          }
          const catHeader = e.target.closest('.budget-category-header');
          if (catHeader && !e.target.closest('.budget-input')) {
            const card = catHeader.closest('.budget-category-card');
            if (card) card.setAttribute('data-expanded', card.getAttribute('data-expanded') === 'true' ? 'false' : 'true');
          }
        });
        const applyBudgetChange = (inputEl) => {
          if (!inputEl || !inputEl.classList.contains('budget-input')) return;
          const category = inputEl.getAttribute('data-category');
          if (!category) return;
          const raw = inputEl.value.replace(/,/g, '');
          const num = parseFloat(raw);
          if (isNaN(num)) return;
          this.setBudget(category, num);
          const txs2 = this.getTxsForCategory(category);
          const isIncome = this.isIncomeCategory(category);
          const spend = this.getSpending(txs2);
          const income = this.getIncome(txs2);
          const b = this.getBudget(category);
          const comm = this.getCommitted(category);
          const val = isIncome ? income : spend;
          const totalWithComm = val + comm;
          const inst = this.chartInstances[category];
          if (inst) {
            const maxVal = Math.max(Math.abs(b), Math.abs(totalWithComm), 1);
            const scaleMin = 0;
            const scaleMax = maxVal;
            const pctForColor = Math.abs(b) > 0 ? Math.abs(totalWithComm) / Math.abs(b) : 0;
            const barColor = pctForColor <= 0.8 ? '#22c55e' : (pctForColor <= 1 ? '#eab308' : '#ef4444');
            const [r, g, bVal] = barColor === '#22c55e' ? [34, 197, 94] : (barColor === '#eab308' ? [234, 179, 8] : [239, 68, 68]);
            const commCurOrPast = this.getCommittedCurrentOrPast(category);
            const commFuture = this.getCommittedFuture(category);
            const barData1 = isIncome ? Math.max(0, val) : Math.max(0, -val);
            const newDatasets = [{ data: [barData1], backgroundColor: barColor, stack: 'stack0' }];
            if (commCurOrPast !== 0) newDatasets.push({ data: [Math.abs(commCurOrPast)], backgroundColor: 'rgba(' + r + ',' + g + ',' + bVal + ',0.66)', stack: 'stack0' });
            if (commFuture !== 0) newDatasets.push({ data: [Math.abs(commFuture)], backgroundColor: 'rgba(' + r + ',' + g + ',' + bVal + ',0.33)', stack: 'stack0' });
            inst.data.datasets = newDatasets;
            inst.options.scales.x.min = scaleMin;
            inst.options.scales.x.max = scaleMax;
            const todayLineVal = Math.abs(b) * todayProgress;
            const budgetLineVal = Math.abs(b);
            if (inst.options.plugins?.budgetLines) {
              inst.options.plugins.budgetLines.todayValue = todayLineVal;
              inst.options.plugins.budgetLines.budgetValue = budgetLineVal;
              inst.options.plugins.budgetLines.spending = Math.abs(totalWithComm);
              inst.options.plugins.budgetLines.isIncome = isIncome;
            }
            inst.update();
          }
          const fmtSigned = (n) => (n >= 0 ? '' : '-') + Math.round(Math.abs(n)).toLocaleString();
          inputEl.value = (b >= 0 ? '' : '-') + Math.round(Math.abs(b)).toLocaleString();
          const labelEl = document.getElementById('budget-label-' + category.replace(/[^a-zA-Z0-9]/g, '-'));
          if (labelEl) labelEl.textContent = category + ' — $' + fmtSigned(val) + (comm !== 0 ? ' + $' + fmtSigned(comm) : '') + ' = $' + fmtSigned(totalWithComm) + ' / $' + fmtSigned(b);
          for (const g of [...new Set(BUDGET_CATEGORIES.map(bc => bc.grouping))]) {
            const groupTotal = BUDGET_CATEGORIES.filter(bc => bc.grouping === g).reduce((s, bc) => s + this.getBudget(bc.category), 0);
            const groupId = 'group-' + g.replace(/[^a-zA-Z0-9]/g, '-');
            const groupTotalEl = document.getElementById('budget-group-total-' + groupId);
            if (groupTotalEl) groupTotalEl.textContent = (groupTotal >= 0 ? '$' : '-$') + Math.round(Math.abs(groupTotal)).toLocaleString();
          }
          this.updateTotals();
        };
        el.addEventListener('change', (e) => { if (e.target.classList.contains('budget-input')) applyBudgetChange(e.target); });
        el.addEventListener('blur', (e) => {
          if (e.target.classList.contains('budget-input')) {
            const inputEl = e.target;
            setTimeout(() => applyBudgetChange(inputEl), 0);
          }
        }, true);
        el.addEventListener('keydown', (e) => {
          if (e.target.classList.contains('budget-input') && e.key === 'Enter') {
            e.preventDefault();
            applyBudgetChange(e.target);
          }
        });
      }
    };

    document.querySelectorAll('.page-tab').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.preventDefault();
        const page = btn.getAttribute('data-page');
        document.querySelectorAll('.page-tab').forEach(b => b.setAttribute('data-active', b.getAttribute('data-page') === page ? 'true' : 'false'));
        document.getElementById('page-investments').setAttribute('data-visible', page === 'investments' ? 'true' : 'false');
        document.getElementById('page-budget').setAttribute('data-visible', page === 'budget' ? 'true' : 'false');
        if (page === 'budget') await budgetChart.init();
      });
    });

    // Initialize all charts (reorder sections in HTML to change display order)
    (async () => {
      const inputs = await loadFinancialSnapshotInputs();
      const bal = inputs && inputs.balance && Object.keys(inputs.balance).length > 0 ? inputs.balance : null;
      if (bal) {
        const el = id => document.getElementById(id);
        if (bal.balance_exclude_realestate !== undefined && el('balance-exclude-realestate')) el('balance-exclude-realestate').checked = !!bal.balance_exclude_realestate;
        if (bal.balance_exclude_automobiles !== undefined && el('balance-exclude-automobiles')) el('balance-exclude-automobiles').checked = !!bal.balance_exclude_automobiles;
        if (bal.balance_exclude_nonmerrill !== undefined && el('balance-exclude-nonmerrill')) el('balance-exclude-nonmerrill').checked = !!bal.balance_exclude_nonmerrill;
      }
      await balanceChart.init();
      (async () => {
        const el = document.getElementById('header-csv-update');
        if (!el) return;
        const d = await getEarliestCsvUpdateDate();
        el.textContent = 'Last complete .csv update:    ' + (d ? formatLongDate(d) : '—');
      })();
      fetchKeyFigures();
      await wealthProjectionChart.init();
      await monteCarloChart.init();
      document.querySelectorAll('.inputs-save-csv-btn').forEach(btn => btn.addEventListener('click', exportFinancialSnapshotInputsCsv));
    })().catch(err => {
      const copyIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>';
      const checkIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>';
      const commands = [
        { label: 'Start a local server:', cmd: 'python -m http.server 8000' },
        { label: 'Or if you use python3:', cmd: 'python3 -m http.server 8000' }
      ];
      const basePath = window.location.pathname.replace(/\/[^/]*$/, '') || '';
      const pageName = window.location.pathname.split('/').pop() || 'financial-snapshot.html';
      const urlCmd = 'http://localhost:8000' + (basePath ? basePath + '/' : '/') + pageName;
      commands.push({ label: 'Then open in your browser:', cmd: urlCmd });
      const boxHtml = '<h2>Unable to load data</h2>' +
        '<p>' + (err?.message || 'A network or server error occurred.') + '</p>' +
        '<p><strong>Tip:</strong> If you saw your browser\'s connection error instead of this page, open <code>start-server.html</code> from this folder (double-click it) to get instructions.</p>' +
        '<p>Run one of these commands in your terminal from the folder containing this file:</p>' +
        commands.map(({ label, cmd }) =>
          '<p style="margin-bottom: 0.25rem; font-size: 0.8125rem; font-weight: 500;">' + label + '</p>' +
          '<div class="error-command-row">' +
          '<code>' + cmd.replace(/</g, '&lt;') + '</code>' +
          '<button type="button" class="copy-btn" title="Copy" data-cmd="' + cmd.replace(/"/g, '&quot;') + '">' + copyIcon + '</button>' +
          '</div>'
        ).join('');
      document.body.innerHTML = '<div class="error-page">' +
        '<h1>Rubin Financial Snapshot</h1>' +
        '<div class="error-box">' + boxHtml + '</div>' +
        '</div>';
      document.querySelectorAll('.error-page .copy-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
          const cmd = btn.getAttribute('data-cmd');
          try {
            await navigator.clipboard.writeText(cmd);
            btn.classList.add('copied');
            btn.innerHTML = checkIcon;
            setTimeout(() => { btn.classList.remove('copied'); btn.innerHTML = copyIcon; }, 2000);
          } catch (_) {}
        });
      });
    });
  </script>
</body>
</html>
